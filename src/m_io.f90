!=========================================================================
! This file is part of MOLGW.
! Author: Fabien Bruneval, Ivan Maliyov, Mauricio Rodriguez-Mayorga
!
! This file contains
! the procedures for input and outputs
!
!=========================================================================
#include "molgw.h"
#if !defined(NO_LIBINT)
#include<libint2/libint2_params.h>
#endif
module m_io
 use,intrinsic :: ISO_FORTRAN_ENV, only: COMPILER_VERSION,COMPILER_OPTIONS
 use m_definitions
 use m_mpi
 use m_timing
 use m_memory
 use m_warning,only: issue_warning
 use m_string_tools,only: orbital_momentum_name
 use m_libint_tools,only: libint_init
 use m_libcint_tools,only: libcint_has_range_separation,check_capability_libcint
 use m_libxc_tools,only: xc_version
 use m_linear_algebra,only: determinant_3x3_matrix
 use m_inputparam
 use m_hamiltonian_tools,only: get_number_occupied_states
 use m_atoms
 use m_basis_set
 use m_dft_grid,only: calculate_basis_functions_r
 use m_cart_to_pure
 use m_eri,only: npair
 use m_elements


 interface dump_out_matrix
   module procedure dump_out_matrix_nospin_dp
   module procedure dump_out_matrix_dp
   module procedure dump_out_matrix_cdp
 end interface


contains


!=========================================================================
!
! Cleanly exit from the code, with all the memory statements, warnings, and timings
!
!=========================================================================
subroutine this_is_the_end()
 implicit none

 !=====
 !=====

 call total_memory_statement()

 call output_timing()

 call output_all_warnings()

 if( print_yaml_ .AND. is_iomaster ) then
   write(unit_yaml,'(/,a)')  'run:'
   write(unit_yaml,'(4x,a,1x,i6)')  'mpi tasks:  ',world%nproc
#if defined(_OPENMP)
   write(unit_yaml,'(4x,a,1x,i6)')  'omp threads:',OMP_GET_MAX_THREADS()
#else
   write(unit_yaml,'(4x,a,1x,i6)')  'omp threads:',1
#endif

   write(unit_yaml,'(4x,a)') 'timing:'
   write(unit_yaml,'(8x,a)')           'unit: s'
   write(unit_yaml,'(8x,a,1x,es18.8)') 'total:  ',get_timing(timing_total)
   write(unit_yaml,'(8x,a,1x,es18.8)') 'prescf: ',get_timing(timing_prescf)
   write(unit_yaml,'(8x,a,1x,es18.8)') 'scf:    ',get_timing(timing_scf)
   write(unit_yaml,'(8x,a,1x,es18.8)') 'postscf:',get_timing(timing_postscf)
   write(unit_yaml,'(4x,a)') 'memory:'
   write(unit_yaml,'(8x,a)')           'unit: Gb'
   write(unit_yaml,'(8x,a,1x,es18.8)') 'peak:   ',get_peak_memory()

   write(unit_yaml,'(a)') '...'
   close(unit_yaml)
 endif

 write(stdout,'(/,1x,a)') 'When using MOLGW for a publication, citation to the following article is appreciated:'
 write(stdout,'(6x,a)')   '    Bruneval, Rangel, Hamed, Shao, Yang, Neaton, Comput. Phys. Comm. 208, 149 (2016).'
 write(stdout,'(/,1x,a,/)') 'This is the end'

 call finish_mpi()

 stop


end subroutine this_is_the_end


!=========================================================================
subroutine header()
 implicit none

!=====
 character(len=40)   :: git_sha
 integer             :: values(8)
 integer             :: nchar,kchar,lchar
 character(len=1024) :: chartmp
!=====
! variables used to call C
 integer(C_INT)      :: ammax=0
 logical(C_BOOL)     :: has_onebody,has_gradient
 integer(C_INT)      :: libxc_version(3)
!=====

! Here we call the fortran code that was generated by the python script
! Any new variable should be added through the python script
#include "git_sha.f90"

!=====

 write(stdout,'(1x,70("="))')
 write(stdout,'(/,/,12x,a,/)') 'Welcome to the fascinating world of MOLGW'
 write(stdout,'(24x,a)')       MOLGW_VERSION
 write(stdout,'(/,/,1x,70("="))')

 write(stdout,'(/,a,a,/)') ' MOLGW commit git SHA: ',git_sha
 write(stdout,'(1x,a,a)')    'compiled with ',COMPILER_VERSION()
 write(stdout,'(1x,a)')      'with options: '
 chartmp = COMPILER_OPTIONS()
 nchar = LEN(TRIM(chartmp))
 kchar = 1
 lchar = 0
 do
   lchar = SCAN(chartmp(kchar:nchar),' ')
   if( lchar == 0 ) exit
   write(stdout,'(6x,a,a)') 'FCFLAGS ',chartmp(kchar:kchar+lchar-1)
   kchar = kchar + lchar
 enddo
 write(stdout,*)


 call date_and_time(VALUES=values)

 write(stdout,'(a,i2.2,a,i2.2,a,i4.4)') ' Today is ',values(2),'/',values(3),'/',values(1)
 write(stdout,'(a,i2.2,a,i2.2)')        ' It is now ',values(5),':',values(6)
 select case(values(5))
 case(03,04,05,06,07)
   write(stdout,*) 'And it is too early to work. Go back to sleep'
 case(22,23,00,01,02)
   write(stdout,*) 'And it is too late to work. Go to bed and have a sleep'
 case(12,13)
   write(stdout,*) 'Go and get some good food'
 case(17)
   write(stdout,*) 'Dont forget to go and get the kids'
 case default
   write(stdout,*) 'And it is perfect time to work'
 end select


 write(stdout,'(/,1x,a)') 'Preprocessing and runtime options:'
#if !defined(NO_LIBXC)
 write(stdout,*) 'Running with LIBXC'
 call xc_version(libxc_version(1),libxc_version(2),libxc_version(3))
 write(chartmp,'(i2,a,i2,a,i2)') libxc_version(1),'.',libxc_version(2),'.',libxc_version(3)
 write(stdout,'(5x,a,a)') 'LIBXC version: ',TRIM(chartmp)
#else
 write(stdout,*) 'Running without LIBXC'
 write(stdout,*) 'Hartree-Fock-only code'
#endif


 ! Parallelization details
#if defined(_OPENMP)
 write(stdout,'(1x,a,i4)') 'Running with OPENMP parallelization activated with max threads count: ',OMP_GET_MAX_THREADS()
#endif
#if defined(HAVE_MPI) && defined(HAVE_SCALAPACK)
 write(stdout,*) 'Running with MPI'
 write(stdout,*) 'Running with SCALAPACK'
#endif
#if defined(HAVE_MPI) && !defined(HAVE_SCALAPACK)
 call die('Code compiled with SCALAPACK, but without MPI. This is not permitted')
#endif
#if !defined(HAVE_MPI) && defined(HAVE_SCALAPACK)
 call die('Code compiled with MPI, but without SCALAPACK. This is not permitted')
#endif


 !
 ! Integrals section
 !

 ! LIBINT details
 call libint_init(ammax,has_onebody,has_gradient)

#if !defined(NO_LIBINT)
 write(stdout,'(1x,a,i5)') 'Code compiled with LIBINT support with max angular momentum: ',ammax
#endif

 ! LIBCINT details
#if defined(HAVE_LIBCINT)
 has_onebody = .TRUE.
 call check_capability_libcint(ammax)
 write(stdout,'(1x,a,i5)') 'Code compiled with LIBCINT support with max angular momentum: ',ammax
 if( .NOT. libcint_has_range_separation ) then
   write(stdout,'(1x,a,i5)') 'Current LIBCINT compilation has no range-separation capability'
 endif
#endif

#if !defined(HAVE_LIBCINT) && defined(NO_LIBINT)
 write(stdout,*) 'Code compiled with no integral library: nor LIBINT nor LIBCINT'
 call die('Please compile MOLGW with LIBINT or LIBCINT')
#endif

 call set_molgw_lmax(ammax,has_onebody,has_gradient)

 if( has_onebody ) then
   write(stdout,'(1x,a)')  'Running with external LIBINT or LIBCINT calculation of the one-body operators (faster)'
 else
   write(stdout,'(1x,a)')  'Running with internal calculation of the one-body operators (slower)'
 endif

#if defined(LIBINT2_DERIV_ONEBODY_ORDER) && (LIBINT2_DERIV_ONEBODY_ORDER > 0)
 write(stdout,'(1x,a)') 'Running with external LIBINT calculation of the gradients of the one-body integrals'
#endif
#if defined(LIBINT2_DERIV_ERI_ORDER) && (LIBINT2_DERIV_ERI_ORDER > 0)
 write(stdout,'(1x,a)') 'Running with external LIBINT calculation of the gradients of the Coulomb integrals'
#endif
 write(stdout,*)
 write(stdout,*)


end subroutine header


!=========================================================================
subroutine dump_out_matrix_dp(print_matrix,title,matrix)
 implicit none
 logical,intent(in)          :: print_matrix
 character(len=*),intent(in) :: title
 real(dp),intent(in)         :: matrix(:,:,:)
 !=====
 integer,parameter :: MAXSIZE=50
 !=====
 real(dp) :: row(MIN(SIZE(matrix,DIM=2),MAXSIZE))
 integer  :: imat,ispin,nspin,mmat,nmat
 !=====

 if( .NOT. print_matrix .AND. .NOT. debug ) return

 mmat  = SIZE(matrix,DIM=1)
 nmat  = SIZE(matrix,DIM=2)
 nspin = SIZE(matrix,DIM=3)

 write(stdout,'(/,1x,a)') TRIM(title)

 do ispin=1,nspin
   if(nspin==2) then
     write(stdout,'(a,i1)') ' spin polarization # ',ispin
   endif
   do imat=1,MIN(mmat,MAXSIZE)
     where( ABS(matrix(imat,1:MIN(nmat,MAXSIZE),ispin)) > 1.0e-5_dp )
       row(:) = matrix(imat,1:MIN(nmat,MAXSIZE),ispin)
     elsewhere
       row(:) = 1.0e-6_dp
     end where
     write(stdout,'(1x,i3,*(1x,f12.5))') imat,row(:)
   enddo
   write(stdout,*)
 enddo
 write(stdout,*)

end subroutine dump_out_matrix_dp


!=========================================================================
subroutine dump_out_matrix_nospin_dp(print_matrix,title,matrix)
 implicit none
 logical,intent(in)          :: print_matrix
 character(len=*),intent(in) :: title
 real(dp),intent(in)         :: matrix(:,:)
 !=====
 integer,parameter :: MAXSIZE=50
 !=====
 real(dp) :: row(MIN(SIZE(matrix,DIM=2),MAXSIZE))
 integer :: imat,mmat,nmat
 !=====

 if( .NOT. print_matrix .AND. .NOT. debug ) return

 mmat  = SIZE(matrix,DIM=1)
 nmat  = SIZE(matrix,DIM=2)

 write(stdout,'(/,1x,a)') TRIM(title)

 do imat=1,MIN(mmat,MAXSIZE)
   where( ABS(matrix(imat,1:MIN(nmat,MAXSIZE))) > 1.0e-5_dp )
     row(:) = matrix(imat,1:MIN(nmat,MAXSIZE))
   elsewhere
     row(:) = 1.0e-6_dp
   end where
   write(stdout,'(1x,i3,*(1x,f12.5))') imat,row(:)
 enddo
 write(stdout,*)

end subroutine dump_out_matrix_nospin_dp


!=========================================================================
subroutine dump_out_matrix_cdp(print_matrix,title,matrix)
 implicit none
 logical,intent(in)          :: print_matrix
 character(len=*),intent(in) :: title
 complex(dp),intent(in)      :: matrix(:,:,:)
 !=====
 integer,parameter :: MAXSIZE=50
 !=====
 real(dp) :: row(MIN(SIZE(matrix,DIM=2),MAXSIZE))
 integer  :: imat,ispin,mmat,nmat,nspin
 !=====

 if( .NOT. print_matrix .AND. .NOT. debug ) return

 mmat  = SIZE(matrix,DIM=1)
 nmat  = SIZE(matrix,DIM=2)
 nspin = SIZE(matrix,DIM=3)

 write(stdout,'(/,1x,a)') TRIM(title)

 do ispin=1,nspin
   if(nspin==2) then
     write(stdout,'(a,i1)') ' spin polarization # ',ispin
   endif
   do imat=1,MIN(mmat,MAXSIZE)
     where( ABS(matrix(imat,1:MIN(nmat,MAXSIZE),ispin)) > 1.0e-5_dp )
       row(:) = matrix(imat,1:MIN(nmat,MAXSIZE),ispin)
     elsewhere
       row(:) = 1.0e-6_dp
     end where
     write(stdout,'(1x,i3,*(1x,2(1x,f12.5)))') imat,row(:)
   enddo
   write(stdout,*)
 enddo
 write(stdout,*)

end subroutine dump_out_matrix_cdp


!=========================================================================
subroutine mulliken_pdos(basis,s_matrix,c_matrix,occupation,energy)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: s_matrix(:,:)
 real(dp),intent(in)        :: c_matrix(:,:,:)
 real(dp),intent(in)        :: occupation(:,:),energy(:,:)
!=====
 integer                    :: nstate
 integer                    :: ibf,li,ibf1,ibf2,ishell
 integer                    :: natom1,natom2,istate,ispin
 logical                    :: file_exists
 integer                    :: pdosfile
 real(dp)                   :: proj_state_i(0:basis%ammax),proj_charge
 real(dp)                   :: cs_vector_i(basis%nbf)
 integer                    :: iatom_ibf(basis%nbf)
 integer                    :: li_ibf(basis%nbf)
 integer                    :: ielement,iemax,icenter
 integer                    :: atom2element(ncenter_basis)
 character(len=4)           :: char4
 character(len=2)           :: char2
 real(dp),allocatable       :: proj_element(:,:)
 integer,allocatable        :: element_list(:)
 real(dp)                   :: weight
 integer,parameter          :: lmax = 2
!=====

 if( .NOT. is_iomaster ) return

 nstate = SIZE(occupation(:,:),DIM=1)

 write(stdout,*)
 write(stdout,*) 'Projecting wavefunctions on selected atoms'

 inquire(file='manual_pdos',exist=file_exists)
 if(file_exists) then
   write(stdout,*) 'Opening file:','manual_pdos'
   open(newunit=pdosfile,file='manual_pdos',status='old')
   read(pdosfile,*) natom1,natom2
   close(pdosfile)
 else
   natom1=1
   natom2=1
 endif
 write(stdout,'(1x,a,i5,2x,i5)') 'Range of atoms considered: ',natom1,natom2

 if( print_yaml_ ) write(unit_yaml,'(/,a)') 'mulliken projections:'

 do ishell=1,basis%nshell
   ibf1    = basis%shell(ishell)%istart
   ibf2    = basis%shell(ishell)%iend

   iatom_ibf(ibf1:ibf2) = basis%shell(ishell)%icenter
   li_ibf(ibf1:ibf2)    = basis%shell(ishell)%am
 enddo

 ! Find the unique elements in the system
 iemax = 0
 do ielement=1,nelement_max
   if( ANY(zbasis(1:ncenter_basis) == ielement) ) then
     iemax = iemax + 1
   endif
   do icenter=1,ncenter_basis
     if( zbasis(icenter) == ielement ) atom2element(icenter) = iemax
   enddo
 enddo
 allocate(proj_element(0:lmax+1,iemax),element_list(iemax))
 iemax = 0
 do ielement=1,nelement_max
   if( ANY(zbasis(1:ncenter_basis) == ielement) ) then
     iemax = iemax + 1
     element_list(iemax) = ielement
   endif
 enddo

 write(stdout,'(1x,a)') '==========================================='
 write(stdout,'(1x,a)') 'spin state  energy(eV)  Mulliken proj. total        proj s         proj p      proj d ... '

 proj_charge = 0.0_dp

 do ispin=1,nspin

   if( print_yaml_ ) write(unit_yaml,'(4x,a,i2,a)') 'spin channel',ispin,':'

   do istate=1,nstate
     proj_state_i(:) = 0.0_dp
     proj_element(:,:) = 0.0_dp
     write(char4,'(i4)') istate

     cs_vector_i(:) = MATMUL( s_matrix(:,:) , c_matrix(:,istate,ispin) )

     do ibf=1,basis%nbf
       if( iatom_ibf(ibf) >= natom1 .AND. iatom_ibf(ibf) <= natom2 ) then
         li = li_ibf(ibf)
         proj_state_i(li) = proj_state_i(li) + c_matrix(ibf,istate,ispin) * cs_vector_i(ibf)
       endif
       weight = c_matrix(ibf,istate,ispin) * cs_vector_i(ibf)
       proj_element(MIN(li_ibf(ibf),lmax+1),atom2element(iatom_ibf(ibf))) = &
                proj_element(MIN(li_ibf(ibf),lmax+1),atom2element(iatom_ibf(ibf))) + weight
     enddo
     proj_charge = proj_charge + occupation(istate,ispin) * SUM(proj_state_i(:))

     if( print_yaml_) then
       write(unit_yaml,'(8x,a4,a)') ADJUSTL(char4),':'
       do ielement=1,iemax
         write(unit_yaml,'(12x,a2,a)') ADJUSTL(element_name(REAL(element_list(ielement),dp))),':'
         do li=0,lmax
           write(char2,'(i2)') li
           write(unit_yaml,'(16x,a2,3x,a,1x,es18.8)') ADJUSTL(char2),':',proj_element(li,ielement)
         enddo
         write(unit_yaml,'(16x,a,1x,es18.8)') 'total:',SUM(proj_element(:,ielement))
       enddo
     endif

     write(stdout,'(i3,1x,i5,1x,20(f16.6,4x))') ispin,istate,energy(istate,ispin) * Ha_eV,&
          SUM(proj_state_i(:)),proj_state_i(:)

   enddo
 enddo

 write(stdout,'(1x,a)') '==========================================='
 write(stdout,'(1x,a,f12.6)') 'Total Mulliken charge: ',proj_charge

 deallocate(proj_element)

end subroutine mulliken_pdos


!=========================================================================
subroutine mulliken_pdos_cmplx(basis,s_matrix,c_matrix_cmplx,occupation,file_mulliken,time_cur)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: s_matrix(:,:)
 real(dp),intent(in)        :: time_cur
 real(dp),intent(in)        :: occupation(:,:)
 complex(dp),intent(in)     :: c_matrix_cmplx(:,:,:)
!=====
 integer                    :: ibf,li,ibf1,ibf2,ishell,n_column
 integer                    :: natom1,natom2,istate,ispin,atom_sampled
 logical                    :: file_exists
 integer                    :: pdosfile
 integer,intent(in)         :: file_mulliken
 complex(dp)                :: proj_state_i(0:basis%ammax)
 complex(dp)                :: proj_charge(ncenter_basis)
 complex(dp)                :: cs_vector_i(basis%nbf)
 integer                    :: iatom_ibf(basis%nbf)
 integer                    :: li_ibf(basis%nbf)
 integer                    :: iatom_basis, nocc
 character(len=20)          :: myfmt
 integer,parameter          :: lmax = 2
!=====

 !if( .NOT. is_iomaster ) return

 inquire(file='manual_pdos',exist=file_exists)
 if(file_exists) then
   open(newunit=pdosfile,file='manual_pdos',status='old')
   read(pdosfile,*) natom1,natom2
   close(pdosfile)
 else
   natom1=1
   natom2=1
 endif

 do ishell=1,basis%nshell
   ibf1    = basis%shell(ishell)%istart
   ibf2    = basis%shell(ishell)%iend

   !! Label basis functions with atom index
   iatom_ibf(ibf1:ibf2) = basis%shell(ishell)%icenter
   !! Label basis functions with angular momentum index
   li_ibf(ibf1:ibf2)    = basis%shell(ishell)%am
 enddo

 nocc        = get_number_occupied_states(occupation)
 proj_charge = ( 0.0_dp, 0.0_dp )

 do atom_sampled = natom1,natom2
 do ispin=1,nspin

   !! Only loop over occupied states
   do istate=1, nocc
     proj_state_i(:) = ( 0.0_dp, 0.0_dp )

     cs_vector_i(:) = MATMUL( s_matrix(:,:) , CONJG(c_matrix_cmplx(:,istate,ispin)) )

     do ibf=1,basis%nbf
       if( iatom_ibf(ibf) == atom_sampled ) then
         li = li_ibf(ibf)
         proj_state_i(li) = proj_state_i(li) + c_matrix_cmplx(ibf,istate,ispin) * cs_vector_i(ibf)
       endif
     enddo
     proj_charge(atom_sampled) = proj_charge(atom_sampled) &
                        + occupation(istate,ispin) * SUM(proj_state_i(:))

   enddo

 enddo
 enddo

 n_column = 2 + ncenter_basis
 write( myfmt, '("(1x,",I0,"(2x,es18.8))")' ) n_column
 if ( is_iomaster ) then
   if ( file_mulliken /= stdout ) then
     write( file_mulliken, fmt=myfmt ) time_cur, xatom(3,ncenter_nuclei), REAL( proj_charge )
   else
     write( stdout, * ) 'Mulliken projectile charge = ', REAL( proj_charge(natom2) )
   end if
 end if


end subroutine mulliken_pdos_cmplx


!=========================================================================
subroutine lowdin_pdos(basis,s_matrix_sqrt,c_matrix,occupation,energy)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: s_matrix_sqrt(:,:)
 real(dp),intent(in)        :: c_matrix(:,:,:)
 real(dp),intent(in)        :: occupation(:,:),energy(:,:)
!=====
 integer                    :: nstate
 integer                    :: ibf,li,ibf1,ibf2,ishell
 integer                    :: natom1,natom2,istate,ispin
 logical                    :: file_exists
 integer                    :: pdosfile
 real(dp)                   :: proj_state_i(0:basis%ammax),proj_charge
 real(dp)                   :: cs_vector_i(basis%nbf)
 integer                    :: iatom_ibf(basis%nbf)
 integer                    :: li_ibf(basis%nbf)
 integer                    :: iatom_basis
 character(len=4)           :: char4
 character(len=2)           :: char2
 integer,parameter          :: lmax = 2
!=====

 if( .NOT. is_iomaster ) return

 nstate = SIZE(occupation,DIM=1)

 write(stdout,*)
 write(stdout,*) 'Projecting wavefunctions on selected atoms'

 inquire(file='manual_pdos',exist=file_exists)
 if(file_exists) then
   write(stdout,*) 'Opening file:','manual_pdos'
   open(newunit=pdosfile,file='manual_pdos',status='old')
   read(pdosfile,*) natom1,natom2
   close(pdosfile)
 else
   natom1=1
   natom2=1
 endif
 write(stdout,'(1x,a,i5,2x,i5)') 'Range of atoms considered: ',natom1,natom2

 do ishell=1,basis%nshell
   ibf1    = basis%shell(ishell)%istart
   ibf2    = basis%shell(ishell)%iend

   iatom_ibf(ibf1:ibf2) = basis%shell(ishell)%icenter
   li_ibf(ibf1:ibf2)    = basis%shell(ishell)%am
 enddo

 write(stdout,'(1x,a)') '==========================================='
 write(stdout,'(1x,a)') 'spin state  energy(eV)  Lowdin proj. total        proj s         proj p      proj d ... '

 proj_charge = 0.0_dp

 do ispin=1,nspin

   do istate=1,nstate
     proj_state_i(:) = 0.0_dp
     write(char4,'(i4)') istate

     cs_vector_i(:) = MATMUL( s_matrix_sqrt(:,:) , c_matrix(:,istate,ispin) )

     do ibf=1,basis%nbf
       if( iatom_ibf(ibf) >= natom1 .AND. iatom_ibf(ibf) <= natom2 ) then
         li = li_ibf(ibf)
         proj_state_i(li) = proj_state_i(li) + cs_vector_i(ibf)**2
       endif
     enddo
     proj_charge = proj_charge + occupation(istate,ispin) * SUM(proj_state_i(:))

     write(stdout,'(i3,1x,i5,1x,20(f16.6,4x))') ispin,istate,energy(istate,ispin) * Ha_eV,&
          SUM(proj_state_i(:)),proj_state_i(:)

   enddo
 enddo

 write(stdout,'(1x,a)') '==========================================='
 write(stdout,'(1x,a,f12.6)') 'Total Lowdin charge: ',proj_charge


end subroutine lowdin_pdos



!=========================================================================
subroutine lowdin_pdos_cmplx(basis,s_matrix_sqrt,c_matrix_cmplx,occupation,file_lowdin,time_cur,atom_state_occ)
 implicit none
 integer,intent(in)             :: file_lowdin
 integer,intent(inout),optional :: atom_state_occ(:,:)
 type(basis_set),intent(in)     :: basis
 real(dp),intent(in)            :: s_matrix_sqrt(:,:)
 real(dp),intent(in)            :: time_cur
 real(dp),intent(in)            :: occupation(:,:)
 complex(dp),intent(in)         :: c_matrix_cmplx(:,:,:)
!=====
 integer                        :: ibf,li,ibf1,ibf2,ishell,ibf_ibf,n_column
 integer                        :: natom1,natom2,istate,ispin,atom_sampled
 logical                        :: file_exists
 integer                        :: pdosfile
 complex(dp)                    :: proj_state_i(0:basis%ammax)
 complex(dp)                    :: cs_vector_i(basis%nbf)
 integer                        :: iatom_ibf(basis%nbf)
 integer                        :: li_ibf(basis%nbf)
 real(dp),allocatable           :: proj_charge(:)!,proj_charge_orb(:)
 integer,allocatable            :: nbf_per_atom(:)
 integer                        :: iatom_basis,nocc,natom_total,count_nbf,offset_nbf
 character(len=20)              :: myfmt
 integer,parameter              :: lmax = 2
!=====

 !if( .NOT. is_iomaster ) return
 if( PRESENT(atom_state_occ) ) atom_state_occ(:,:) = 0

 inquire(file='manual_pdos',exist=file_exists)
 if(file_exists) then
   open(newunit=pdosfile,file='manual_pdos',status='old')
   read(pdosfile,*) natom1,natom2
   close(pdosfile)
 else
   if( PRESENT( atom_state_occ ) ) then
     call die("=== FILE ABSENT FOR TDDFT : manual_pdos ===")
   else
     natom1=ncenter_nuclei  ! by convention the last atom is the projectile
     natom2=ncenter_nuclei  ! by convention the last atom is the projectile
   end if
 endif

 natom_total = natom2 - natom1 + 1
 allocate(nbf_per_atom(natom_total))
 nbf_per_atom(:) = 0

 do ishell=1,basis%nshell
   ibf1    = basis%shell(ishell)%istart
   ibf2    = basis%shell(ishell)%iend

   !! Label basis functions with atom index
   iatom_ibf(ibf1:ibf2) = basis%shell(ishell)%icenter
   do atom_sampled = natom1,natom2
     if (atom_sampled == basis%shell(ishell)%icenter) then
       nbf_per_atom(atom_sampled-natom1+1) = nbf_per_atom(atom_sampled-natom1+1) + ibf2-ibf1+1
     end if
   end do
   !! Label basis functions with angular momentum index
   li_ibf(ibf1:ibf2)    = basis%shell(ishell)%am
 enddo

 nocc        = get_number_occupied_states(occupation)
 allocate(proj_charge(natom_total))
 !allocate(proj_charge_orb(nbf_per_atom(end)))
 proj_charge(:) = 0.0_dp
 !proj_charge_orb(:) = 0.0_dp

 offset_nbf = 0
 do atom_sampled = natom1,natom2
 do ispin=1,nspin

   !! Only loop over occupied states
   do istate=1, SIZE(c_matrix_cmplx, DIM=2)
     proj_state_i(:) = ( 0.0_dp, 0.0_dp )

     cs_vector_i(:) = MATMUL( s_matrix_sqrt(:,:) , CONJG(c_matrix_cmplx(:,istate,ispin)) )

     count_nbf = 0
     do ibf=1,basis%nbf
       if ( iatom_ibf(ibf) == atom_sampled ) then
         count_nbf = count_nbf + 1
         li = li_ibf(ibf)
         proj_state_i(li) = proj_state_i(li) + ABS( cs_vector_i(ibf) )**2
         !proj_charge_orb(count_nbf + offset_nbf) = proj_charge_orb(count_nbf + offset_nbf) &
          !              + occupation(istate,ispin) * REAL(ABS( cs_vector_i(ibf) )**2)
       endif
     enddo
     proj_charge(atom_sampled-natom1+1) = proj_charge(atom_sampled-natom1+1) &
                        + occupation(istate,ispin) * REAL(SUM(proj_state_i(:)))

     if ( PRESENT( atom_state_occ ) ) then
       if ( NINT(REAL(SUM(proj_state_i(:)))) == 1 ) then
         atom_state_occ(istate, ispin) = atom_sampled
       end if
     end if
   enddo

 enddo
 offset_nbf = sum(nbf_per_atom(1:atom_sampled-natom1+1))
 enddo

 n_column = 4 + natom_total ! + size(proj_charge_orb)
 write( myfmt, '("(1x,",I0,"(2x,es18.8))")' ) n_column
 if ( is_iomaster ) then
   if ( file_lowdin /= stdout ) then
     write( file_lowdin, fmt=myfmt ) time_cur, xatom(:,ncenter_nuclei), proj_charge(:)!, proj_charge_orb(:)
   end if
   write(stdout,'(1x,a,es14.6)') 'Lowdin projectile charge: ', proj_charge(natom_total)
 end if

 deallocate(proj_charge)!, proj_charge_orb)
 deallocate(nbf_per_atom)

end subroutine lowdin_pdos_cmplx


!=========================================================================
subroutine plot_wfn(basis,c_matrix)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: c_matrix(:,:,:)
!=====
 integer,parameter          :: nr=2000
 integer                    :: nstate
 real(dp),parameter         :: length=10.0_dp
 integer                    :: ir
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:),phase(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: wfrfile
!=====

 if( .NOT. is_iomaster ) return

 nstate = SIZE(c_matrix,DIM=2)

 write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions'
 inquire(file='manual_plotwfn',exist=file_exists)
 if(file_exists) then
   open(newunit=wfrfile,file='manual_plotwfn',status='old')
   read(wfrfile,*) u(:)
   read(wfrfile,*) a(:)
   close(wfrfile)
 else
   u(:)=0.0_dp
   u(1)=1.0_dp
   a(:)=0.0_dp
 endif
 u(:) = u(:) / SQRT(SUM(u(:)**2))
 allocate(phase(cube_state_min:cube_state_max,nspin),phi(cube_state_min:cube_state_max,nspin))
 write(stdout,'(a,2(2x,i4))')   ' states:   ',cube_state_min,cube_state_max
 write(stdout,'(a,3(2x,f8.3))') ' direction:',u(:)
 write(stdout,'(a,3(2x,f8.3))') ' origin:   ',a(:)

 xxmin = MINVAL( u(1)*xbasis(1,:) + u(2)*xbasis(2,:) + u(3)*xbasis(3,:) ) - length
 xxmax = MAXVAL( u(1)*xbasis(1,:) + u(2)*xbasis(2,:) + u(3)*xbasis(3,:) ) + length

 phase(:,:)=1.0_dp

 do ir=1,nr
   rr(:) = ( xxmin + (ir-1)*(xxmax-xxmin)/REAL(nr-1,dp) ) * u(:) + a(:)


   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi(cube_state_min:cube_state_max,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,cube_state_min:cube_state_max,ispin) )
   enddo

   !
   ! turn the wfns so that they are all positive at a given point
   if(ir==1) then
     do ispin=1,nspin
       do istate=cube_state_min,cube_state_max
         if( phi(istate,ispin) < 0.0_dp ) phase(istate,ispin) = -1.0_dp
       enddo
     enddo
   endif

   write(101,'(50(e16.8,2x))') DOT_PRODUCT(rr(:),u(:)),phi(:,:)*phase(:,:)
   write(102,'(50(e16.8,2x))') DOT_PRODUCT(rr(:),u(:)),phi(:,:)**2

 enddo

 deallocate(phase,phi)

end subroutine plot_wfn


!=========================================================================
subroutine plot_wfn_fourier(basis,c_matrix)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: c_matrix(:,:,:)
!=====
 integer                    :: nstate
 real(dp)                   :: qunit(3),qvec(3)
 integer                    :: iq,istate,ibf,ishell
 integer                    :: gt,li,ni_cart,ibf1,ibf1_cart,ibf2,i_cart
 complex(dp)                :: basis_function_q(basis%nbf)
 complex(dp),allocatable    :: basis_function_q_cart(:)
 integer,allocatable        :: file_state(:)
 character(len=4)           :: cstate
 integer,parameter :: n1=86
 integer,parameter :: nqradial=30
 integer,parameter          :: nq=200
 real(dp),parameter         :: dq=0.10_dp
 !integer,parameter          :: nq=n1*nqradial
 !integer :: ix1,iqradial
 real(dp) :: xtmp,weight
 !real(dp) :: qlist(3,nq),wq(nq)
 !real(dp) :: x1(n1),y1(n1),z1(n1),w1(n1)
 !real(dp) :: xa(nqradial),wxa(nqradial)
 !real(dp),parameter :: alpha= 5.0_dp
 !real(dp),allocatable       :: ekin(:)
!=====

 nstate = SIZE(c_matrix,DIM=2)
 qunit(1) = 1.0_dp
 qunit(2) = 1.0_dp
 qunit(3) = 1.0_dp
 qunit(:) = qunit(:) / NORM2(qunit(:))

 gt = get_gaussian_type_tag(basis%gaussian_type)

 allocate(file_state(cube_state_min:cube_state_max))
 do istate=cube_state_min,cube_state_max
   write(cstate,'(i4.4)') istate
   open(newunit=file_state(istate),file='wfn_fourier_'//cstate//'.dat',action='write')
 enddo

 !allocate(ekin(cube_state_min:cube_state_max))
 !ekin(:) = 0.0_dp

 !do iqradial=1,nqradial
 !  xtmp = ( iqradial - 0.5_dp ) / REAL(nqradial,dp)
 !  xa(iqradial)   = -alpha * log( 1.0_dp - xtmp**3)
 !  wxa(iqradial)  = 3.0_dp * alpha * xtmp**2 / ( 1.0_dp - xtmp**3 ) / REAL(nqradial,dp)
 !enddo
 !call ld0086(x1,y1,z1,w1,iq)
 !iq = 0
 !do iqradial=1,nqradial
 !  do ix1=1,n1
 !    iq = iq + 1
 !    wq(iq) = wxa(iqradial) * w1(ix1) * 4.0_dp * pi * xa(iqradial)**2
 !    qlist(1,iq) = xa(iqradial) * x1(ix1)
 !    qlist(2,iq) = xa(iqradial) * y1(ix1)
 !    qlist(3,iq) = xa(iqradial) * z1(ix1)
 !  enddo
 !enddo


 do iq=1,nq
   qvec(:) = qunit(:) * iq * dq
   !weight = 4.0_dp * pi * NORM2(qvec)**2 * dq
   !qvec(:) = qlist(:,iq)
   !weight = wq(iq)

   do ishell=1,basis%nshell
     li        = basis%shell(ishell)%am
     ni_cart   = number_basis_function_am('CART',li)
     ibf1      = basis%shell(ishell)%istart
     ibf1_cart = basis%shell(ishell)%istart_cart
     ibf2      = basis%shell(ishell)%iend

     allocate(basis_function_q_cart(ni_cart))

     do i_cart=1,ni_cart
       basis_function_q_cart(i_cart) = basis_function_fourier(basis%bfc(ibf1_cart+i_cart-1),qvec)
     enddo
     basis_function_q(ibf1:ibf2) = MATMUL( TRANSPOSE(cart_to_pure(li,gt)%matrix(:,:)), basis_function_q_cart(:) )
     deallocate(basis_function_q_cart)

   enddo


   do istate=cube_state_min,cube_state_max
     write(file_state(istate),'(f12.5,2x,2(1x,es16.6))') NORM2(qvec(:)),DOT_PRODUCT(basis_function_q(:),c_matrix(:,istate,1))
     !ekin(istate) = ekin(istate) + weight * NORM2(qvec)**2 &
     !                                * ABS(DOT_PRODUCT(basis_function_q(:),c_matrix(:,istate,1)))**2 * ( 2.0_dp *pi )**3
   enddo

 enddo

 do istate=cube_state_min,cube_state_max
   !write(stdout,*) 'kinetic energy',istate,0.5_dp*ekin(istate)
   close(file_state(istate))
 enddo
 deallocate(file_state)
 !deallocate(ekin)

end subroutine plot_wfn_fourier


!=========================================================================
subroutine plot_rho(rootname,basis,occupation,c_matrix)
 implicit none
 type(basis_set),intent(in)  :: basis
 real(dp),intent(in)         :: occupation(:,:)
 real(dp),intent(in)         :: c_matrix(:,:,:)
 character(len=*),intent(in) :: rootname
!=====
 integer,parameter          :: nr=5000
 real(dp),parameter         :: length=8.0_dp
 integer                    :: nstate
 integer                    :: ir
 integer                    :: ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: rhorfile
 integer                    :: unit_rho
!=====

 if( .NOT. is_iomaster ) return

 write(stdout,'(/,1x,a)') 'Plotting the density'

 nstate = SIZE(occupation,DIM=1)

 inquire(file='manual_plotrho',exist=file_exists)
 if(file_exists) then
   open(newunit=rhorfile,file='manual_plotrho',status='old')
   read(rhorfile,*) u(:)
   read(rhorfile,*) a(:)
   close(rhorfile)
 else
   u(:)=0.0_dp
   u(1)=1.0_dp
   a(:)=0.0_dp
 endif
 u(:) = u(:) / NORM2(u)
 allocate(phi(nstate,nspin))
 write(stdout,'(a,3(2x,f8.3))') ' direction:',u(:)
 write(stdout,'(a,3(2x,f8.3))') ' origin:   ',a(:)

 xxmin = MINVAL( u(1)*xbasis(1,:) + u(2)*xbasis(2,:) + u(3)*xbasis(3,:) ) - length
 xxmax = MAXVAL( u(1)*xbasis(1,:) + u(2)*xbasis(2,:) + u(3)*xbasis(3,:) ) + length

 open(newunit=unit_rho,file=TRIM(rootname)//'_density_cut.dat',action='write')
 write(unit_rho,*) '#   r (bohr)      rho(r) (e/bohr**3) '
 do ir=1,nr
   rr(:) = ( xxmin + (ir-1)*(xxmax-xxmin)/REAL(nr-1,dp) ) * u(:) + a(:)


   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )
   enddo

   write(unit_rho,'(2(1x,e14.6))') DOT_PRODUCT(rr(:),u(:)),SUM( phi(:,:)**2 * occupation(:,:) )

 enddo
 close(unit_rho)

 deallocate(phi)

end subroutine plot_rho


!=========================================================================
subroutine plot_rho_xy(basis,occupation,c_matrix)
 implicit none
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(:,:)
 real(dp),intent(in)        :: c_matrix(:,:,:)
!=====
 integer                    :: nrxy, nrz
 real(dp),parameter         :: length = 4.0_dp
 integer                    :: nstate
 integer                    :: irx, iry, irz
 integer                    :: ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:)
 real(dp)                   :: drxy, drz, rho_xy
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: unit_rho
!=====

 !if( .NOT. is_iomaster ) return

 write(stdout,'(/,1x,a)') 'Plotting the density'

 nstate = SIZE(occupation,DIM=1)

 nrxy = 50
 nrz = 200

 drxy = ( 2.01755_dp*1.88973_dp + length ) / REAL(nrxy-1, dp)
 drz = ( MAXVAL(xbasis(3,:)) - MINVAL(xbasis(3,:)) + 2.0_dp*length ) / REAL(nrz-1, dp)

 rr(1) = 0.0_dp - 0.5_dp*length - drxy

 allocate( phi(nstate, nspin) )

 open(newunit = unit_rho, file = 'density_plane_xy.dat', action = 'write')
 do irx = 1, nrxy
   rr(1) = rr(1) + drxy
   rr(2) = 0.0_dp - 0.5_dp*length - drxy

   do iry = 1, nrxy
     rr(2) = rr(2) + drxy
     rr(3) = MINVAL(xbasis(3,:)) - length - drz

     rho_xy = 0.0_dp
     do irz = 1, nrz
       rr(3) = rr(3) + drz

       call calculate_basis_functions_r(basis, rr, basis_function_r)

       do ispin=1,nspin
         phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )
       end do

       rho_xy = rho_xy + SUM( phi(:,:)**2 * occupation(:,:) )
     end do

     write(unit_rho, '(3(1x,e12.5))') rr(1:2) / 1.88973_dp, rho_xy / REAL(nrz, dp)

   end do
 end do
 close(unit_rho)

 deallocate(phi)

end subroutine plot_rho_xy


!=========================================================================
subroutine plot_rho_list(nstate,basis,occupation,c_matrix)
 implicit none
 integer,intent(in)         :: nstate
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
!=====
 integer                    :: ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: rhorfile
 integer                    :: ix,iy,iz
 real(dp),parameter         :: dx = 0.174913 ! 0.204034
 real(dp)                   :: rr0(3)
 integer                    :: unitfile
!=====

 if( .NOT. is_iomaster ) return

 write(stdout,'(/,1x,a)') 'Plotting the density'


 inquire(file='manual_plotrho',exist=file_exists)
 if(file_exists) then
   open(newunit=rhorfile,file='manual_plotrho',status='old')
   close(rhorfile)
 else
 endif
 allocate(phi(nstate,nspin))

 rr0(1) = -6.512752 ! -8.790885
 rr0(2) = -6.512752 ! -9.143313
 rr0(3) = -7.775444 ! -6.512752

 open(newunit=unitfile,file='rho.dat',action='WRITE')
 do ix=1,cube_nx
 do iy=1,cube_ny
 do iz=1,cube_nz
   rr(1) = ix-1
   rr(2) = iy-1
   rr(3) = iz-1
   rr(:) = rr0(:) + rr(:) * dx


   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )
   enddo

   write(unitfile,'(1x,e16.8)') SUM( phi(3:,:)**2 * occupation(3:,:) )

 enddo
 enddo
 enddo
 close(unitfile)

 deallocate(phi)

end subroutine plot_rho_list


!=========================================================================
subroutine plot_cube_wfn(rootname,basis,occupation,c_matrix)
 implicit none
 character(len=*),intent(in) :: rootname
 type(basis_set),intent(in)  :: basis
 real(dp),intent(in)         :: occupation(:,:)
 real(dp),intent(in)         :: c_matrix(:,:,:)
!=====
 integer                     :: nstate
 real(dp),parameter          :: length=3.499470_dp
 integer                     :: istate,ispin
 real(dp)                    :: rr(3)
 real(dp),allocatable        :: phi(:,:)
 real(dp)                    :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                    :: dx,dy,dz
 real(dp)                    :: basis_function_r(basis%nbf)
 integer                     :: ix,iy,iz,icenter
 integer,allocatable         :: ocubefile(:,:)
 integer                     :: ocuberho(nspin)
 character(len=200)          :: file_name
 integer                     :: icubefile
!=====

 if( .NOT. is_iomaster ) return

 write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions in a cube file'

 nstate = SIZE(occupation(:,:),DIM=1)

 if( cube_state_min < 1 )      call die('plot_cube_wfn: cube_state_min should be >= 1')
 if( cube_state_max > nstate ) call die('plot_cube_wfn: cube_state_max should be < nstate')

 allocate(phi(cube_state_min:cube_state_max,nspin))
 write(stdout,'(a,2(2x,i4))')   ' states:   ',cube_state_min,cube_state_max

 xmin =MIN(MINVAL( xatom(1,:) ),MINVAL( xbasis(1,:) )) - length
 xmax =MAX(MAXVAL( xatom(1,:) ),MAXVAL( xbasis(1,:) )) + length
 ymin =MIN(MINVAL( xatom(2,:) ),MINVAL( xbasis(2,:) )) - length
 ymax =MAX(MAXVAL( xatom(2,:) ),MAXVAL( xbasis(2,:) )) + length
 zmin =MIN(MINVAL( xatom(3,:) ),MINVAL( xbasis(3,:) )) - length
 zmax =MAX(MAXVAL( xatom(3,:) ),MAXVAL( xbasis(3,:) )) + length
 dx = (xmax-xmin)/REAL(cube_nx,dp)
 dy = (ymax-ymin)/REAL(cube_ny,dp)
 dz = (zmax-zmin)/REAL(cube_nz,dp)
! xmin = -15.001591d0
! ymin = -15.001591d0
! zmin = -17.037892d0
! dx = 0.262502_dp
! dy = 0.262502_dp
! dz = 0.262502_dp

 allocate(ocubefile(cube_state_min:cube_state_max,nspin))

 do istate=cube_state_min,cube_state_max
   do ispin=1,nspin
     write(file_name,'(a,i3.3,a,i1,a)') 'wfn_'//TRIM(rootname)//'_',istate,'_',ispin,'.cube'
     open(newunit=ocubefile(istate,ispin),file=file_name)
     write(ocubefile(istate,ispin),'(a)') 'cube file generated from MOLGW'
     write(ocubefile(istate,ispin),'(a,i4)') 'wavefunction ',istate
     write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin,zmin
     write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') cube_nx,dx,0.,0.
     write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') cube_ny,0.,dy,0.
     write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') cube_nz,0.,0.,dz
     do icenter=1,ncenter_nuclei
       write(ocubefile(istate,ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
     enddo
   enddo
 enddo

 !
 ! check whether cube_state_min:cube_state_max spans all the occupied states
 if( .TRUE. ) then
   do ispin=1,nspin
     write(file_name,'(a,i1,a)') 'rho_'//TRIM(rootname)//'_',ispin,'.cube'
     open(newunit=ocuberho(ispin),file=file_name)
     write(ocuberho(ispin),'(a)') 'cube file generated from MOLGW'
     write(ocuberho(ispin),'(a,i4)') 'density for spin ',ispin
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin,zmin
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nx,dx,0.,0.
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_ny,0.,dy,0.
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nz,0.,0.,dz
     do icenter=1,ncenter_nuclei
       write(ocuberho(ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
     enddo
   enddo

   do ix=1,cube_nx
     rr(1) = xmin + (ix-1)*dx
     do iy=1,cube_ny
       rr(2) = ymin + (iy-1)*dy
       do iz=1,cube_nz
         rr(3) = zmin + (iz-1)*dz

         call calculate_basis_functions_r(basis,rr,basis_function_r)

         do ispin=1,nspin
           phi(cube_state_min:cube_state_max,ispin) = MATMUL( basis_function_r(:) , &
                                                              c_matrix(:,cube_state_min:cube_state_max,ispin) )
         enddo

         do ispin=1,nspin
           write(ocuberho(ispin),'(50(e16.8,2x))') SUM( phi(:,ispin)**2 * occupation(cube_state_min:cube_state_max,ispin) )
         enddo


         do istate=cube_state_min,cube_state_max
           do ispin=1,nspin
             write(ocubefile(istate,ispin),'(50(e16.8,2x))') phi(istate,ispin)
           enddo
         enddo

       enddo
     enddo
   enddo


   do ispin=1,nspin
     do istate=cube_state_min,cube_state_max
       close(ocubefile(istate,ispin))
     enddo
     close(ocuberho(ispin))
   enddo
 endif

 deallocate(phi)
 deallocate(ocubefile)

end subroutine plot_cube_wfn


!=========================================================================
! This routine prints WFN files:
! Author: Mauricio Rodriguez-Mayorga
!=========================================================================
subroutine print_wfn_file(rootname,basis,occupation,c_matrix,etotal,energy)
 implicit none
 character(len=*)             :: rootname
 type(basis_set),intent(in)   :: basis
 real(dp),intent(in)          :: etotal
 real(dp),intent(in)          :: occupation(:,:)
 real(dp),intent(in)          :: c_matrix(:,:,:)
 real(dp),intent(in),optional :: energy(:,:)
!=====
 integer,parameter      :: el_max    = 106
 real(dp),parameter     :: TOL_COEFF = 1.0e-8_dp
 character(len=200)     :: file_name
 integer                :: nstate,icenter,iprim,nprim,igaus,ishell,nshell,shell_typ,prev_typ
 integer                :: istyp,iprim_per_shell,iprint,ilast,istate,ibf,ibf2,nocc,ispin,nxp,nyp,nzp
 integer                :: owfn
 real(dp)               :: dfact
 integer                :: p_aos(3)
 integer                :: d_aos(6)
 integer                :: f_aos(10)
 integer                :: g_aos(15)
 integer,allocatable    :: icent(:),itype(:),prim_per_shell(:),ao_map(:)
 real(dp),allocatable   :: expon(:),prim_coefs(:),mo_coefs(:)
 real(dp),allocatable   :: energy_local(:,:),coefs_prims(:,:)
 character(len=4),parameter :: el_list(el_max) =                                           &
 (/'  H ','  HE','  LI','  BE','  B ','  C ','  N ','  O ','  F ','  NE','  NA','  MG',    &
   '  AL','  SI','  P ','  S ','  CL','  AR','  K ','  CA','  SC','  TI','  V ','  CR',    &
   '  MN','  FE','  CO','  NI','  CU','  ZN','  GA','  GE','  AS','  SE','  BR','  KR',    &
   '  RB','  SR','  Y ','  ZR','  NB','  MO','  TC','  RU','  RH','  PD','  AG','  CD',    &
   '  IN','  SN','  SB','  TE','  I ','  XE','  CS','  BA','  LA','  CE','  PR','  ND',    &
   '  PM','  SM','  EU','  GD','  TB','  DY','  HO','  ER','  TM','  YB','  LU','  HF',    &
   '  TA','  W ','  RE','  OS','  IR','  PT','  AU','  HG','  TL','  PB','  BI','  PO',    &
   '  AT','  RN','  FR','  RA','  AC','  TH','  PA','  U ','  NP','  PU','  AM','  CM',    &
   '  BK','  CF','  ES','  FM','  MD','  NO','  LR','    ','    ','    '                   &
  /)

 if( .NOT. is_iomaster ) return

 if( basis%gaussian_type /= 'CART' ) then ! Pure, not implemented (TODO)
   write(stdout,'(/,1x,a)') "Computation of WFN files requires cartesian gaussian functions"
   write(stdout,'(1x,a,/)') "Include: gaussian_type = 'cart' in the input file and run again the calculation."
   call issue_warning('print_wfn_file: not coded for PURE Gaussians as of today')
   return
 endif

 nstate = MIN( SIZE(occupation(:,:),DIM=1), SIZE(c_matrix(:,:,:),DIM=2) )

 write(stdout,'(/,1x,a,/)') 'Preparing the WFN file'

 write(file_name,'(a,i1,a)') "molgw_"//TRIM(rootname)//'_',1,'.wfn'
 open(newunit=owfn,file=file_name)

 nocc = 0
 do istate=1,nstate
   do ispin=1,nspin
     if( ABS(occupation(istate,ispin) ) > completely_empty ) nocc = nocc + 1
   enddo
 enddo

 nprim = SUM(basis%bfc(:)%ngaussian)
 write(owfn,'(a80)') 'MOLGW WFN file generated'
 write(owfn,'(a8,10x,i5,a13,1x,i6,a11,4x,i5,a7)') 'GAUSSIAN',nocc,' MOL ORBITALS',nprim,' PRIMITIVES',ncenter_nuclei,' NUCLEI'
 do icenter=1,ncenter_nuclei
   write(owfn,'(a4,i4,4x,a7,i3,a1,1x,3f12.8,a10,f5.1)') el_list(NINT(zatom(icenter))),icenter, &
   '(CENTRE',icenter,')',xatom(:,icenter),'  CHARGE =',zatom(icenter)
 enddo

 allocate(icent(nprim),itype(nprim),expon(nprim),prim_coefs(nprim))
 !We have: MO = COEF_AO*AO | and | AO = COEF_P*Primitives
 !We need: MO = COEF*Primitives. Thus, we compute COEF = COEF_AO*COEF_P -> stored finally in prim_coefs variable for each MO before printing.
 !Currently we store all COEF_P at once, to construct COEF on the fly we may need to rebuild COEF_P for any MO.
 !Comment: Indeed, any program that will read the WFN file should store all 'coefs_prims' matrix at once.
 !         So, in that machine such amount of RAM memory is available.
 !
 allocate(coefs_prims(basis%nbf,nprim),ao_map(basis%nbf))
 icent = 0
 itype = 0
 expon = 0.0_dp
 coefs_prims(:,:) = 0.0_dp
 prim_coefs(:) = 0.0_dp
 nshell=SIZE(basis%shell(:)%icenter)

 do ibf=1,basis%nbf
   ao_map(ibf) = ibf
 enddo

 ibf=1
 ibf2=1
 iprim=1
 do ishell=1,nshell
   shell_typ=basis%shell(ishell)%am   ! 0 for s, 1 for p, 2 for d, 3 for f,...,

   iprim_per_shell=number_basis_function_am('CART',shell_typ)

   prev_typ=0
   do istyp=0,shell_typ-1
     prev_typ = prev_typ + number_basis_function_am('CART',istyp)
   enddo
   allocate(prim_per_shell(iprim_per_shell))
   do istyp=1,iprim_per_shell
     prim_per_shell(istyp) = istyp + prev_typ
   enddo


   ! Order MO Coefs
   if(shell_typ==1) then                    ! p-shell
     p_aos(1:3)=ao_map(ibf2:ibf2+2)
     ao_map(ibf2:ibf2+2)=p_aos(:)
   elseif(shell_typ==2) then                ! d-shell
     d_aos(1:6)=ao_map(ibf2:ibf2+5)
     ao_map(ibf2  )=d_aos(1)
     ao_map(ibf2+1)=d_aos(4)
     ao_map(ibf2+2)=d_aos(6)
     ao_map(ibf2+3)=d_aos(2)
     ao_map(ibf2+4)=d_aos(3)
     ao_map(ibf2+5)=d_aos(5)
   elseif(shell_typ==3) then                ! f-shell
     f_aos(1:10)=ao_map(ibf2:ibf2+9)
     ao_map(ibf2  )=f_aos(1)
     ao_map(ibf2+1)=f_aos(7)
     ao_map(ibf2+2)=f_aos(10)
     ao_map(ibf2+3)=f_aos(2)
     ao_map(ibf2+4)=f_aos(3)
     ao_map(ibf2+5)=f_aos(8)
     ao_map(ibf2+6)=f_aos(4)
     ao_map(ibf2+7)=f_aos(6)
     ao_map(ibf2+8)=f_aos(9)
     ao_map(ibf2+9)=f_aos(5)
   elseif(shell_typ==4) then                ! g-shell
     g_aos(1:15)=ao_map(ibf2:ibf2+14)
     ao_map(ibf2  )=g_aos( 1)
     ao_map(ibf2+1)=g_aos(11)
     ao_map(ibf2+2)=g_aos(15)
     ao_map(ibf2+3)=g_aos( 2)
     ao_map(ibf2+4)=g_aos( 3)
     ao_map(ibf2+5)=g_aos( 7)
     ao_map(ibf2+6)=g_aos(12)
     ao_map(ibf2+7)=g_aos(10)
     ao_map(ibf2+8)=g_aos(14)
     ao_map(ibf2+9)=g_aos( 4)
     ao_map(ibf2+10)=g_aos( 6)
     ao_map(ibf2+11)=g_aos(13)
     ao_map(ibf2+12)=g_aos( 5)
     ao_map(ibf2+13)=g_aos( 8)
     ao_map(ibf2+14)=g_aos( 9)
   elseif(shell_typ==0) then                ! s-shell
    ! Do nothing
   else                ! h-, i-,...shell
     write(stdout,'(1x,a,i5,a)') "Shell type",shell_typ," not reordered."
   endif
   ibf2 = ibf2 + iprim_per_shell

   do istyp=1,iprim_per_shell
     do igaus=1,basis%shell(ishell)%ng
       nxp=0;nyp=0;nzp=0
       if(shell_typ==1) then         ! p-shell
         select case(istyp)
         case(1)
           nxp=1;nyp=0;nzp=0
         case(2)
           nxp=0;nyp=1;nzp=0
         case(3)
           nxp=0;nyp=0;nzp=1
         end select
       endif
       if(shell_typ==2) then         ! d-shell
         select case(istyp)
         case(1)
           nxp=2;nyp=0;nzp=0
         case(2)
           nxp=0;nyp=2;nzp=0
         case(3)
           nxp=0;nyp=0;nzp=2
         case(4)
           nxp=1;nyp=1;nzp=0
         case(5)
           nxp=1;nyp=0;nzp=1
         case(6)
           nxp=0;nyp=1;nzp=1
         end select
       endif
       if(shell_typ==3) then         ! f-shell
         select case(istyp)
         case(1)
           nxp=3;nyp=0;nzp=0
         case(2)
           nxp=0;nyp=3;nzp=0
         case(3)
           nxp=0;nyp=0;nzp=3
         case(4)
           nxp=2;nyp=1;nzp=0
         case(5)
           nxp=2;nyp=0;nzp=1
         case(6)
           nxp=0;nyp=2;nzp=1
         case(7)
           nxp=1;nyp=2;nzp=0
         case(8)
           nxp=1;nyp=0;nzp=2
         case(9)
           nxp=0;nyp=1;nzp=2
         case(10)
           nxp=1;nyp=1;nzp=1
         end select
       endif
       if(shell_typ==4) then         ! g-shell
         select case(istyp)
         case(1)
           nxp=4;nyp=0;nzp=0
         case(2)
           nxp=0;nyp=4;nzp=0
         case(3)
           nxp=0;nyp=0;nzp=4
         case(4)
           nxp=3;nyp=1;nzp=0
         case(5)
           nxp=3;nyp=0;nzp=1
         case(6)
           nxp=1;nyp=3;nzp=0
         case(7)
           nxp=0;nyp=3;nzp=1
         case(8)
           nxp=1;nyp=0;nzp=3
         case(9)
           nxp=0;nyp=1;nzp=3
         case(10)
           nxp=2;nyp=2;nzp=0
         case(11)
           nxp=2;nyp=0;nzp=2
         case(12)
           nxp=0;nyp=2;nzp=2
         case(13)
           nxp=2;nyp=1;nzp=1
         case(14)
           nxp=1;nyp=2;nzp=1
         case(15)
           nxp=1;nyp=1;nzp=2
         end select
       endif
       nxp=2*nxp-1;nyp=2*nyp-1;nzp=2*nzp-1
       dfact = double_factorial(nxp) * double_factorial(nyp) * double_factorial(nzp)
       prim_coefs(iprim) = basis%shell(ishell)%coeff(igaus) / SQRT(dfact)
       itype(iprim) = prim_per_shell(istyp)
       icent(iprim) = basis%shell(ishell)%icenter
       expon(iprim) = basis%shell(ishell)%alpha(igaus)
       iprim = iprim + 1
     enddo
     coefs_prims(ibf,:) = prim_coefs(:)
     prim_coefs(:) = 0.0_dp
     ibf = ibf + 1
   enddo
   deallocate(prim_per_shell)
 enddo


 do iprint=1,nprim/20
   if(20+(iprint-1)*20 <= nprim) then
     write(owfn,'(a18,2x,20i3)') 'CENTRE ASSIGNMENTS',icent(1+(iprint-1)*20:20+(iprint-1)*20)
     ilast=20+(iprint-1)*20
   endif
 enddo
 if(ilast/=nprim) write(owfn,'(a18,2x,*(i3))') 'CENTRE ASSIGNMENTS',icent(ilast+1:)

 do iprint=1,nprim/20
   if(20+(iprint-1)*20 <= nprim) then
     write(owfn,'(a16,4x,20i3)') 'TYPE ASSIGNMENTS',itype(1+(iprint-1)*20:20+(iprint-1)*20)
   endif
 enddo
 if(ilast/=nprim) write(owfn,'(a16,4x,*(i3))') 'TYPE ASSIGNMENTS',itype(ilast+1:)

 do iprint=1,nprim/5
   if(5+(iprint-1)*5 <= nprim) then
     write(owfn,'(a9,1x,1P,5E14.7)') 'EXPONENTS',expon(1+(iprint-1)*5:5+(iprint-1)*5)
   endif
   ilast=5+(iprint-1)*5
 enddo
 if(ilast/=nprim) write(owfn,'(a9,1x,1P,5E14.7)') 'EXPONENTS',expon(ilast+1:)

 allocate(energy_local(nstate,nspin))

 energy_local(:,:) = 0.0_dp
 if(PRESENT(energy)) then
   energy_local(:,:) = energy(:,:)
 endif

 !write(*,*) ' '
 !do ibf=1,basis%nbf
 !  write(*,'(*(f7.3))') coefs_prims(ibf,:)
 !enddo
 !write(*,*) ' '

 allocate(mo_coefs(basis%nbf))

 do istate=1,nstate
   do ispin=1,nspin
     if( ABS(occupation(istate,ispin)) > completely_empty ) then
       mo_coefs(:) = c_matrix(ao_map(:),istate,ispin)
       !write(*,'(*(f7.3))') mo_coefs(:)
       prim_coefs(1:nprim) = MATMUL(mo_coefs(:),coefs_prims(:,1:nprim))
       do iprim=1,nprim
         if( ABS(prim_coefs(iprim)) < TOL_COEFF ) prim_coefs(iprim) = 0.0_dp
       enddo
       write(owfn,'(a2,i5,5x,a6,8x,a9,f12.7,a15,f12.6)') 'MO',istate,'MO 0.0','OCC NO = ',occupation(istate,ispin), &
       '  ORB. ENERGY =',energy_local(istate,ispin)
       write(owfn,'(1P,5E16.8)') prim_coefs(:)
     endif
   enddo
 enddo

 deallocate(icent,itype,expon,prim_coefs,coefs_prims,mo_coefs)

 write(owfn,'(a8)') 'END DATA'
 write(owfn,'(a8,a9,f20.12,a18,f13.8)') ' THE SCF',' ENERGY =',etotal,' THE VIRIAL(-V/T)=',0.0_dp
 close(owfn)

end subroutine print_wfn_file


!=========================================================================
subroutine plot_rho_traj_bunch(nstate,nocc_dim,basis,occupation,c_matrix,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer                    :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: nr=1000,nh=100
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp),parameter         :: length=6.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi(:,:)
 real(dp)                   :: point_a(3),point_b(3),point_c(3),u(3)
 real(dp)                   :: a_cur(3), b_cur(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ir,ih,icenter
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: line_rho(nspin)
 character(len=200)         :: file_name
 integer                    :: linefile
 integer                    :: i_max_atom
 real(dp)                   :: vec_length
 real(dp)                   :: integral, deltar
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting electronic density along the projectile trajectory for several impact parameters'
 endif
 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_rho_traj_bunch subroutine')
   endif
 enddo

 inquire(file='manual_dens_traj',exist=file_exists)
 if(file_exists) then
   open(newunit=linefile,file='manual_dens_traj_tddft',status='old')
   read(linefile,*) point_a(:)
   read(linefile,*) point_b(:)
   read(linefile,*) point_c(:)
   read(linefile,*) nr
   read(linefile,*) nh

   close(linefile)
 else
   point_a = (/ 0.0_dp,  0.0_dp, -10.0_dp  /)
   point_b = (/ 0.0_dp,  0.0_dp,  10.0_dp  /)
   point_c = (/ 3.49_dp, 0.0_dp, -10.0_dp  /)
   call issue_warning('plot_rho_traj_bunch: manual_dens_traj_tddft file was not found')
 endif
! point_b(:) = point_b(:) / bohr_A
! point_a(:) = point_a(:) / bohr_A
! In analogy with cube file, this file is also in Bohr
 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi(nstate,nspin))

 do ispin=1,nspin
   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_integral_density.dat'
   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_rho(ispin),'(a,f9.5)') '# time_cur = ', time_cur
 enddo

 deltar=NORM2( point_b(:) - point_a(:) )/nr
 do ih=0,nh
   do ispin=1,nspin

     a_cur(:)=point_a(:)+(point_c(:)-point_a(:))*ih/nh
     b_cur(:)=point_b(:)+(point_c(:)-point_a(:))*ih/nh

     integral=0.d0
!     write(stdout,*) ih
     do ir=0,nr
       rr(:) = a_cur(:) + ( b_cur(:) - a_cur(:) ) * ir / nr
       call calculate_basis_functions_r(basis,rr,basis_function_r)
       phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )
       integral=integral+SUM( (phi(:,ispin))**2 * occupation(:,ispin) )*deltar
     enddo

     write(line_rho(ispin),'(50(e16.8,2x))') NORM2(a_cur(:)-point_a(:)),integral
   enddo
 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
 end do

 deallocate(phi)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_traj_bunch


!=========================================================================
subroutine plot_rho_traj_bunch_contrib(nstate,basis,occupation,c_matrix,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer                    :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: nr=1000,nh=100
 integer                    :: gt
 real(dp),parameter         :: length=6.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:)
 real(dp)                   :: point_a(3),point_b(3),point_c(3),u(3)
 real(dp)                   :: a_cur(3), b_cur(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ir,ih,icenter
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: line_rho(nspin)
 integer                    :: line_phi_square(nspin)
 character(len=200)         :: file_name
 integer                    :: linefile
 integer                    :: statesfile
 integer                    :: i_max_atom
 integer                    :: nocc
 integer,allocatable        :: istate_cut(:,:)
 real(dp)                   :: vec_length
 real(dp)                   :: deltar,path_length
 real(dp),allocatable       :: integral(:)
 real(dp),allocatable       :: integral_phi_square(:)
 integer                    :: iline,ncut,num_fields,icut
 character(len=500)         :: cur_string
!=====

 if( .NOT. is_iomaster ) return

 nocc=0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty ) cycle
     if( istate > nocc ) nocc = istate
   enddo
 end do

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting electronic density along the projectile trajectory for several impact parameters'
 endif

 inquire(file='manual_dens_traj',exist=file_exists)
 if(file_exists) then
   open(newunit=linefile,file='manual_dens_traj',status='old')
   read(linefile,*) point_a(:)
   read(linefile,*) point_b(:)
   read(linefile,*) point_c(:)
   read(linefile,*) nr
   read(linefile,*) nh

   close(linefile)
 else
   point_a = (/ 0.0_dp,  0.0_dp, -10.0_dp  /)
   point_b = (/ 0.0_dp,  0.0_dp,  10.0_dp  /)
   point_c = (/ 3.49_dp, 0.0_dp, -10.0_dp  /)
   call issue_warning('plot_rho_traj_bunch: manual_dens_traj file was not found')
 endif

 inquire(file='manual_dens_traj_states',exist=file_exists)
 if(file_exists) then
   ncut=get_number_of_lines('manual_dens_traj_states')
   allocate(istate_cut(ncut,2))
   open(newunit=statesfile,file='manual_dens_traj_states',status='old')
   do iline=1,ncut
     read(statesfile,'(A)') cur_string
     num_fields = get_number_of_elements(cur_string)
     if( num_fields == 2 ) then
       read(cur_string,*) istate_cut(iline,1), istate_cut(iline,2)
     else if( num_fields == 1) then
       read(cur_string,*) istate_cut(iline,1)
       istate_cut(iline,2) = nstate
     else
       call die("manual_q_matrix_param must contain 1 or two fields.")
     endif

   end do
   close(statesfile)
 else
   ncut=2
   allocate(istate_cut(2,2))
   istate_cut(1,1) = 1; istate_cut(1,2) = 1;
   istate_cut(2,1) = 2; istate_cut(2,2) = nstate;
   call issue_warning('plot_rho_traj_bunch_contrib: manual_dens_traj_states file was not found')
 endif

 allocate(integral(ncut))
 allocate(integral_phi_square(ncut))
! point_b(:) = point_b(:) / bohr_A
! point_a(:) = point_a(:) / bohr_A
! In analogy with cube file, this file is also in Bohr
 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi(nstate,nspin))

 do ispin=1,nspin
   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_contribution_integral_density.dat'

   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_rho(ispin),'(a,f9.5)') '# time_cur = ', time_cur

   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_contribution_phi_square.dat'
   open(newunit=line_phi_square(ispin),file=file_name)
   write(line_phi_square(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_phi_square(ispin),'(a,f9.5)') '# time_cur = ', time_cur
 enddo

 deltar=NORM2( point_b(:) - point_a(:) )/nr
 path_length=NORM2(point_b(:)-point_a(:))
 do ispin=1,nspin

   do ih=0,nh

     a_cur(:)=point_a(:)+(point_c(:)-point_a(:))*REAL(ih,dp)/REAL(nh,dp)
     b_cur(:)=point_b(:)+(point_c(:)-point_a(:))*REAL(ih,dp)/REAL(nh,dp)

     integral=0.0_dp
     integral_phi_square=0.0_dp

     do ir=0,nr
       rr(:) = a_cur(:) + ( b_cur(:) - a_cur(:) ) * REAL(ir,dp) / REAL(nr,dp)
       call calculate_basis_functions_r(basis,rr,basis_function_r)
       phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )

       do icut=1,ncut
         do istate=istate_cut(icut,1),istate_cut(icut,2)
           integral(icut)=integral(icut)+(phi(istate,ispin))**2 * occupation(istate,ispin)
           integral_phi_square(icut)=integral_phi_square(icut)+(phi(istate,ispin))**2
         end do
       end do

     end do
     integral(:)=integral(:)/REAL(nr+1,dp)
     integral_phi_square(:)=integral_phi_square(:)/REAL(nr+1,dp)

     write(line_phi_square(ispin),'(50(f14.8,2x))') NORM2(a_cur(:)-point_a(:)),integral_phi_square(:)
     write(line_rho(ispin),'(50(f14.8,2x))') NORM2(a_cur(:)-point_a(:)),integral(:)
   enddo

 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
   close(line_phi_square(ispin))
 end do

 deallocate(phi)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_traj_bunch_contrib


!=========================================================================
subroutine plot_rho_traj_points_set_contrib(nstate,basis,occupation,c_matrix,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer                    :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: nr=1000,nh=100
 integer                    :: gt
 real(dp),parameter         :: length=6.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 real(dp),allocatable       :: phi(:,:)
 real(dp)                   :: point_a(3),point_b(3),point_c(3)
 real(dp)                   :: a_cur(3), b_cur(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ir,ih,icenter
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: line_rho(nspin)
 integer                    :: line_phi_square(nspin)
 character(len=200)         :: file_name
 integer                    :: points_file
 integer                    :: statesfile
 integer                    :: i_max_atom
 integer                    :: nocc
 integer,allocatable        :: istate_cut(:,:)
 real(dp)                   :: vec_length
 real(dp)                   :: deltar,path_length
 real(dp),allocatable       :: integral(:)
 real(dp),allocatable       :: integral_phi_square(:)
 integer                    :: iline,ncut,num_fields,icut
 character(len=500)         :: cur_string
 integer                    :: npoints,ipoint
 real(dp),allocatable       :: rpoints_start(:,:),rpoints_end(:,:)
!=====

 if( .NOT. is_iomaster ) return

 nocc=0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty ) cycle
     if( istate > nocc ) nocc = istate
   enddo
 end do

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting electronic density along the projectile trajectory for several impact parameters'
 endif

 inquire(file='manual_dens_points_set',exist=file_exists)
 if(file_exists) then
   npoints = get_number_of_lines('manual_dens_points_set')
   allocate(rpoints_start(npoints,3))
   allocate(rpoints_end(npoints,3))
   open(newunit=points_file,file='manual_dens_points_set',status='old')
   do iline=1,npoints
     read(points_file,*) rpoints_start(iline,:), rpoints_end(iline,:)
     ! manual_dens_points_set file MUST BE IN ANGSTROMS in contrast to similar files
     rpoints_start(iline,:) = rpoints_start(iline,:) / bohr_A
     rpoints_end(iline,:)   = rpoints_end(iline,:) / bohr_A
   end do
   close(points_file)
 else
   allocate(rpoints_start(1,3))
   allocate(rpoints_end(1,3))
   rpoints_start(1,:) = (/ 0.0_dp,  0.0_dp, 0.0_dp  /)
   rpoints_end(1,:)   = (/ 0.0_dp,  0.0_dp, 5.0_dp  /)
   call issue_warning('plot_rho_traj_bunch: manual_dens_points_set file was not found')
 endif

 inquire(file='manual_dens_traj_states',exist=file_exists)
 if(file_exists) then
   ncut = get_number_of_lines('manual_dens_traj_states')
   allocate(istate_cut(ncut,2))
   open(newunit=statesfile,file='manual_dens_traj_states',status='old')
   do iline=1,ncut
     read(statesfile,'(A)') cur_string
     num_fields = get_number_of_elements(cur_string)
     if( num_fields == 2 ) then
       read(cur_string,*) istate_cut(iline,1), istate_cut(iline,2)
     else if( num_fields == 1) then
       read(cur_string,*) istate_cut(iline,1)
       istate_cut(iline,2) = nstate
     else
       call die("manual_q_matrix_param must contain 1 or two fields.")
     endif

   end do
   close(statesfile)
 else
   ncut=2
   allocate(istate_cut(2,2))
   istate_cut(1,1) = 1; istate_cut(1,2) = nstate;
   call issue_warning('plot_rho_traj_bunch_contrib: manual_dens_traj_states file was not found')
 endif

 allocate(integral(ncut))

 allocate(integral_phi_square(ncut))
 allocate(phi(nstate,nspin))

 do ispin=1,nspin
   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_points_set_contrib_integral_dens.dat'

   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_rho(ispin),'(a,f9.5)') '# time_cur = ', time_cur

   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_points_set_contrib_phi_square.dat'
   open(newunit=line_phi_square(ispin),file=file_name)
   write(line_phi_square(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_phi_square(ispin),'(a,f9.5)') '# time_cur = ', time_cur
 enddo

 do ispin=1,nspin

   do ipoint=1,npoints

     deltar=NORM2( rpoints_end(ipoint,:) - rpoints_start(ipoint,:) )/nr

     integral=0.0_dp
     integral_phi_square=0.0_dp

     do ir=0,nr
       rr(:) = rpoints_start(ipoint,:) + (rpoints_end(ipoint,:) - rpoints_start(ipoint,:)) * REAL(ir,dp) / REAL(nr,dp)
       call calculate_basis_functions_r(basis,rr,basis_function_r)
       phi(:,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,:,ispin) )

       do icut=1,ncut
         do istate=istate_cut(icut,1),istate_cut(icut,2)
           integral(icut)=integral(icut)+(phi(istate,ispin))**2 * occupation(istate,ispin)
           integral_phi_square(icut)=integral_phi_square(icut)+(phi(istate,ispin))**2
         end do
       end do

     end do
     integral(:)=integral(:)/REAL(nr+1,dp)
     integral_phi_square(:)=integral_phi_square(:)/REAL(nr+1,dp)

     ! fixme output ONLY x and y coordinate of rpoints_start
     ! output in ANGSTROMS
     write(line_phi_square(ispin),'(50(f14.8,2x))') rpoints_start(ipoint,1:2)*bohr_A,integral_phi_square(:)
     write(line_rho(ispin),'(50(f14.8,2x))') rpoints_start(ipoint,1:2)*bohr_A,integral(:)
   enddo

 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
   close(line_phi_square(ispin))
 end do

 deallocate(phi)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_traj_points_set_contrib


!=========================================================================
subroutine plot_cube_wfn_cmplx(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num)

 implicit none
 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer                    :: num
!=====
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp),parameter         :: length=4.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ix,iy,iz,icenter
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: ocuberho(nspin)
 character(len=200)         :: file_name
 integer                    :: icubefile
 integer                    :: i_max_atom
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_cube_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions in a cube file'
 endif
 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_cube_wfn_cmplx')
   endif
 enddo


 allocate(phi_cmplx(1:nocc_max,nspin))
 if( .NOT. in_rt_tddft ) then
   write(stdout,'(a,2(2x,i4))')   ' states:   ',1,nocc_max
 endif

 if( excit_type%form==EXCIT_PROJECTILE ) then
   i_max_atom=ncenter_nuclei-nprojectile
 else
   i_max_atom=ncenter_nuclei
 endif

 xmin =MIN(MINVAL( xatom(1,1:i_max_atom) ),MINVAL( xbasis(1,:) )) - length
 xmax =MAX(MAXVAL( xatom(1,1:i_max_atom) ),MAXVAL( xbasis(1,:) )) + length
 ymin =MIN(MINVAL( xatom(2,1:i_max_atom) ),MINVAL( xbasis(2,:) )) - length
 ymax =MAX(MAXVAL( xatom(2,1:i_max_atom) ),MAXVAL( xbasis(2,:) )) + length
 zmin =MIN(MINVAL( xatom(3,1:i_max_atom) ),MINVAL( xbasis(3,:) )) - length
 zmax =MAX(MAXVAL( xatom(3,1:i_max_atom) ),MAXVAL( xbasis(3,:) )) + length
 dx = (xmax-xmin)/REAL(cube_nx,dp)
 dy = (ymax-ymin)/REAL(cube_ny,dp)
 dz = (zmax-zmin)/REAL(cube_nz,dp)

 do ispin=1,nspin
   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'.cube'
   open(newunit=ocuberho(ispin),file=file_name)
   write(ocuberho(ispin),'(a)') 'cube file generated from MOLGW'
   write(ocuberho(ispin),'(a,i4)') 'density for spin ',ispin
   write(ocuberho(ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin, zmin
   write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nx,dx,0.,0.
   write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_ny,0.,dy,0.
   write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nz,0.,0.,dz
   do icenter=1,ncenter_nuclei
     write(ocuberho(ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
   enddo
 enddo

 do ix=1,cube_nx
   rr(1) = ( xmin + (ix-1)*dx )
   do iy=1,cube_ny
     rr(2) = ( ymin + (iy-1)*dy )
     do iz=1,cube_nz
       rr(3) = ( zmin + (iz-1)*dz )

       call calculate_basis_functions_r(basis,rr,basis_function_r)

       do ispin=1,nspin
         nocc_max=nocc(ispin)
         phi_cmplx(1:nocc_max,ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,1:nocc_max,ispin) )
         write(ocuberho(ispin),'(50(e16.8,2x))') SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(1:nocc_max,ispin) ) * spin_fact
       enddo

     enddo
   enddo
 enddo

 do ispin=1,nspin
   close(ocuberho(ispin))
 end do

 deallocate(phi_cmplx)

 call stop_clock(timing_print_cube_rho_tddft)

end subroutine plot_cube_wfn_cmplx


!=========================================================================
subroutine calc_density_in_disc_cmplx_regular(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer,intent(in)         :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp)                   :: length
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ix,iy,iz
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: file_out(nspin)
 character(len=200)         :: file_name
 integer                    :: icubefile
 integer                    :: i_max_atom
 real(dp),allocatable       :: charge_layer(:)
!=====

 call start_clock(timing_calc_dens_disc)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Calculate electronic density in discs'
 endif
 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_cube_wfn_cmplx')
   endif
 enddo


 inquire(file='manual_disc_density',exist=file_exists)
 if(file_exists) then
   open(newunit=icubefile,file='manual_disc_density',status='old')
   read(icubefile,*) length
   close(icubefile)
 else
   length=10.0_dp
   call issue_warning('calc_density_in_disc_cmplx_regular: manual file was not found')
 endif
 allocate(phi_cmplx(1:nocc_max,nspin))

 i_max_atom = ncenter_nuclei - nprojectile

 xmin =MINVAL( xatom(1,1:i_max_atom) ) - length
 xmax =MAXVAL( xatom(1,1:i_max_atom) ) + length
 ymin =MINVAL( xatom(2,1:i_max_atom) ) - length
 ymax =MAXVAL( xatom(2,1:i_max_atom) ) + length
 zmin =MINVAL( xatom(3,1:i_max_atom) ) - length
 zmax =MAXVAL( xatom(3,1:i_max_atom) ) + length

 dx = (xmax-xmin)/REAL(cube_nx,dp)
 dy = (ymax-ymin)/REAL(cube_ny,dp)
 dz = (zmax-zmin)/REAL(cube_nz,dp)

 if( is_iomaster ) then
   do ispin=1,nspin
     write(file_name,'(a,i4.4,a,i1,a,i3.3,f0.3,a)') 'disc_dens_',num, "_s_",ispin,"_r_",INT(r_disc),r_disc-INT(r_disc),".dat"
     open(newunit=file_out(ispin),file=file_name)
     write(file_out(ispin),'(a,F12.6,a,3F12.6)') '# Time: ',time_cur, '  Projectile position (A): ',xatom(:,ncenter_nuclei)*bohr_A
   enddo
 endif

 allocate(charge_layer(cube_nz))

 do ispin=1,nspin
   charge_layer(:)=0.0_dp
   do iz=1,cube_nz
     if(MODULO(iz-1,world%nproc)/=world%rank) cycle
     rr(3) = ( zmin + (iz-1)*dz )
     do ix=1,cube_nx
       rr(1) = ( xmin + (ix-1)*dx )
       do iy=1,cube_ny
         rr(2) = ( ymin + (iy-1)*dy )

         if( (rr(1)**2+rr(2)**2)**0.5_dp <= r_disc ) then
           call calculate_basis_functions_r(basis,rr,basis_function_r)
           phi_cmplx(1:nocc(ispin),ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,1:nocc(ispin),ispin) )
           charge_layer(iz)=charge_layer(iz)+SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(1:nocc(ispin),ispin) ) * spin_fact
         endif

       enddo
     enddo
   enddo

   call world%sum(charge_layer(:))

   charge_layer = charge_layer * dx*dy

   if( is_iomaster ) then
     do iz=1,cube_nz
       rr(3) = ( zmin + (iz-1)*dz )
       write(file_out(ispin),'(F16.4,F19.10)') rr(3)*bohr_A,charge_layer(iz)
     end do
     close(file_out(ispin))
   endif

 enddo ! ispin

 deallocate(phi_cmplx)

 call stop_clock(timing_calc_dens_disc)

end subroutine calc_density_in_disc_cmplx_regular


!=========================================================================
subroutine plot_cube_diff_cmplx(basis,occupation,c_matrix_cmplx,initialize)
 implicit none
 type(basis_set),intent(in)  :: basis
 real(dp),intent(in)         :: occupation(:,:)
 complex(dp),intent(in)      :: c_matrix_cmplx(:,:,:)
 logical,intent(in),optional :: initialize
 !=====
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp),parameter         :: length=10.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: u(3),a(3)
 logical                    :: file_exists
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ix,iy,iz,icenter,ir
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: ocuberho(nspin)
 character(len=200)         :: file_name
 real(dp),allocatable       :: dens_diff(:)
 integer,save               :: snapshot_index
 real(dp),save              :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp),save              :: dx,dy,dz
 real(dp),allocatable,save  :: rr(:,:)
 real(dp),allocatable,save  :: cube_density_start(:,:)
 !=====

 call start_clock(timing_print_cube_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions in a cube file'
 endif

 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,SIZE(occupation,DIM=1)
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_cube_wfn_cmplx')
   endif
 enddo


 allocate(phi_cmplx(1:nocc_max,nspin))
 if( .NOT. in_rt_tddft ) then
   write(stdout,'(a,2(2x,i4))')   ' states:   ',1,nocc_max
 endif

 !
 ! First call: initialization and storage
 !
 if( PRESENT(initialize) ) then
   if( initialize) then

     write(stdout,'(/,1x,a)') 'Initialize density for plots'

     snapshot_index = 0
     allocate(rr(3,cube_nx*cube_ny*cube_nz))
     allocate(cube_density_start(cube_nx*cube_ny*cube_nz,nspin))

     ! First find the extreme positions for all the starting positions
     xmin =MIN(MINVAL( xatom(1,:) ),MINVAL( xbasis(1,:) ))
     ymin =MIN(MINVAL( xatom(2,:) ),MINVAL( xbasis(2,:) ))
     zmin =MIN(MINVAL( xatom(3,:) ),MINVAL( xbasis(3,:) ))
     xmax =MAX(MAXVAL( xatom(1,:) ),MAXVAL( xbasis(1,:) ))
     ymax =MAX(MAXVAL( xatom(2,:) ),MAXVAL( xbasis(2,:) ))
     zmax =MAX(MAXVAL( xatom(3,:) ),MAXVAL( xbasis(3,:) ))

     ! Second find the extreme positions for all the final positions
     xmin = MIN(xmin , xatom(1,ncenter_nuclei) + vel_projectile(1) * time_sim )
     ymin = MIN(ymin , xatom(2,ncenter_nuclei) + vel_projectile(2) * time_sim )
     zmin = MIN(zmin , xatom(3,ncenter_nuclei) + vel_projectile(3) * time_sim )
     xmax = MAX(xmax , xatom(1,ncenter_nuclei) + vel_projectile(1) * time_sim )
     ymax = MAX(ymax , xatom(2,ncenter_nuclei) + vel_projectile(2) * time_sim )
     zmax = MAX(zmax , xatom(3,ncenter_nuclei) + vel_projectile(3) * time_sim )

     xmin = xmin - length
     ymin = ymin - length
     zmin = zmin - length
     xmax = xmax + length
     ymax = ymax + length
     zmax = zmax + length

     dx = (xmax-xmin)/REAL(cube_nx,dp)
     dy = (ymax-ymin)/REAL(cube_ny,dp)
     dz = (zmax-zmin)/REAL(cube_nz,dp)

     ir = 0
     do ix=1,cube_nx
       do iy=1,cube_ny
         do iz=1,cube_nz
           ir = ir + 1
           rr(1,ir) = xmin + (ix-1)*dx
           rr(2,ir) = ymin + (iy-1)*dy
           rr(3,ir) = zmin + (iz-1)*dz
         enddo
       enddo
     enddo
     cube_density_start(:,:) = 0.0_dp
     !$OMP PARALLEL PRIVATE(basis_function_r,phi_cmplx)
     !$OMP DO
     do ir=1,cube_nx*cube_ny*cube_nz
       if(MODULO(ir-1,world%nproc)/=world%rank) cycle

       call calculate_basis_functions_r(basis,rr(:,ir),basis_function_r)
       do ispin=1,nspin
         phi_cmplx(1:nocc(ispin),ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,1:nocc(ispin),ispin) )
         cube_density_start(ir,ispin)=SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(1:nocc(ispin),ispin) ) * spin_fact
       enddo
     enddo
     !$OMP END DO
     !$OMP END PARALLEL

     call world%sum(cube_density_start)

   else
     call die('should not happen')
   endif


 else  ! not first call

   write(stdout,'(/,1x,a)') 'Plot density difference'

   snapshot_index = snapshot_index + 1


   if( is_iomaster ) then
     do ispin=1,nspin
       write(file_name,'(i3.3,a,i1,a)') snapshot_index,'_',ispin,'dens_diff.cube'
       open(newunit=ocuberho(ispin),file=file_name)
       write(ocuberho(ispin),'(a)') 'cube file generated from MOLGW'
       write(ocuberho(ispin),'(a,i4)') 'density difference for spin ',ispin
       write(ocuberho(ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin, zmin
       write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nx,dx,0.,0.
       write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_ny,0.,dy,0.
       write(ocuberho(ispin),'(i6,3(f12.6,2x))') cube_nz,0.,0.,dz
       do icenter=1,ncenter_nuclei
         write(ocuberho(ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
       enddo
     enddo
   endif

   call clean_allocate("dens_diff for the cube density",dens_diff,cube_nx*cube_ny*cube_nz,verbose=.FALSE.)

   do ispin=1,nspin

     !call start_clock(timing_tmp0)
     dens_diff(:) = 0.0_dp

     !$OMP PARALLEL PRIVATE(basis_function_r,phi_cmplx)
     !$OMP DO
     do ir=1,cube_nx*cube_ny*cube_nz
       if(MODULO(ir-1,world%nproc)/=world%rank) cycle

       call calculate_basis_functions_r(basis,rr(:,ir),basis_function_r)

       phi_cmplx(1:nocc(ispin),ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,1:nocc(ispin),ispin) )
       dens_diff(ir) = SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(1:nocc(ispin),ispin) ) * spin_fact &
                              - cube_density_start(ir,ispin)

     enddo
     !$OMP END DO
     !$OMP END PARALLEL
     !call stop_clock(timing_tmp0)

     !call start_clock(timing_tmp1)
     call world%sum(dens_diff)
     !call stop_clock(timing_tmp1)

     if( is_iomaster ) then
       !call start_clock(timing_tmp2)
       do ir=1,cube_nx*cube_ny*cube_nz
         write(ocuberho(ispin),'(50(e16.8,2x))') dens_diff(ir)
       end do
       !call stop_clock(timing_tmp2)
     endif

   enddo !do ispin

   do ispin=1,nspin
     close(ocuberho(ispin))
   end do

   deallocate(phi_cmplx)
   call clean_deallocate("dens_diff for the cube density",dens_diff,verbose=.FALSE.)

 endif

 call stop_clock(timing_print_cube_rho_tddft)

end subroutine plot_cube_diff_cmplx


!=========================================================================
subroutine charge_projectile_cmplx(basis,occupation,c_matrix_cmplx)
 implicit none
 type(basis_set),intent(in)  :: basis
 real(dp),intent(in)         :: occupation(:,:)
 complex(dp),intent(in)      :: c_matrix_cmplx(:,:,:)
 !=====
 real(dp),parameter :: radius = 2.0_dp
 integer,parameter :: nr=30
 integer,parameter :: nang=50
 integer  :: n1,ir,iang,ispin
 real(dp) :: x1(nang),y1(nang),z1(nang),w1(nang)
 real(dp) :: rr(3),dr,charge
 real(dp) :: basis_function_r(basis%nbf)
 real(dp) :: phi_cmplx(SIZE(c_matrix_cmplx,DIM=2),nspin)
 !=====

 call ld0050(x1,y1,z1,w1,n1)

 charge = 0.0_dp
 do ir=1,nr
   do iang=1,nang
     rr(1) = ir/REAL(nr,dp) * radius * x1(iang)
     rr(2) = ir/REAL(nr,dp) * radius * y1(iang)
     rr(3) = ir/REAL(nr,dp) * radius * z1(iang)
     dr = SUM(rr(:)**2) * radius / REAL(nr,dp)
     rr(:) = rr(:) + xatom(:,ncenter_nuclei)

     call calculate_basis_functions_r(basis,rr,basis_function_r)

     do ispin=1,nspin
       phi_cmplx(:,ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,:,ispin) )
       charge = charge + SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(:SIZE(c_matrix_cmplx,DIM=2),ispin) ) &
                           * 4.0_dp * pi * w1(iang) * dr
     enddo
   enddo
 enddo
 write(stdout,*) 'charge : ',charge


end subroutine charge_projectile_cmplx


!=========================================================================
subroutine plot_rho_cmplx(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer,intent(in)         :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: nr
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp),parameter         :: length=6.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: point_a(3),point_b(3),u(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ir
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: line_rho(nspin)
 character(len=200)         :: file_name
 integer                    :: linefile
 integer                    :: i_max_atom
 real(dp)                   :: vec_length
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions along one line'
 endif
 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_cube_wfn_cmplx')
   endif
 enddo

 inquire(file='manual_plot_rho_tddft',exist=file_exists)
 if(file_exists) then
   open(newunit=linefile,file='manual_plot_rho_tddft',status='old')
   read(linefile,*) nr
   read(linefile,*) point_a(:)
   read(linefile,*) point_b(:)
   close(linefile)
 else
   nr = 5000
   point_a = (/ 0.0_dp, 0.0_dp, 0.0_dp  /)
   point_b = (/ 0.0_dp, 0.0_dp, 10.0_dp  /)
   call issue_warning('plot_line_wfn_cmplx: manual_plot_rho_tddft file was not found')
 endif
! point_b(:) = point_b(:) / bohr_A
! point_a(:) = point_a(:) / bohr_A
! In analogy with cube file, this file is also in Bohr
 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi_cmplx(nocc_dim,nspin))

 do ispin=1,nspin
   write(file_name,'(i4.4,a,i1,a)') num,'_',ispin,'_line_density.dat'
   open(newunit=line_rho(ispin),file=file_name)
!   write(line_rho(ispin),'(a,i3)') '# line density file generated from MOLGW for spin ',ispin
   write(line_rho(ispin),'(a,F12.6,a,3F12.6)') '# Time: ',time_cur, '  Projectile position (A): ',xatom(:,ncenter_nuclei)*bohr_A
 enddo

 do ir=0,nr
   rr(:) = (ir + 0.0_dp) / nr * ( point_b(:) - point_a(:) ) + point_a(:)

   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi_cmplx(:,ispin) = matmul( basis_function_r(:) , c_matrix_cmplx(:,:,ispin) )
     write(line_rho(ispin),'(50(e16.8,2x))') dot_product(rr(:),u(:)), &
                                             sum( abs(phi_cmplx(:,ispin))**2 * occupation(:nocc_dim,ispin) )
   enddo
 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
 end do

 deallocate(phi_cmplx)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_cmplx


!=========================================================================
subroutine plot_rho_diff_cmplx(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num,time_cur,nr_line_rho,point_a,point_b,rho_start)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer,intent(in)         :: num
 real(dp),intent(in)        :: time_cur
 real(dp),intent(in)        :: point_a(3),point_b(3)
 integer,intent(in)         :: nr_line_rho
 real(dp),intent(in)       :: rho_start(nr_line_rho,nspin)
!=====
 integer                    :: ir,ispin,gt
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: u(3)
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: line_rho(nspin)
 character(len=200)         :: file_name
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 write(stdout,'(/,1x,a)') 'Plotting the electronic density along one line'

 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi_cmplx(nocc_dim,nspin))

 do ispin=1,nspin
   write(file_name,'(a,i4.4,a,i1,a)') 'diff_',num,'_',ispin,'_line_density.dat'
   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,F12.6,a,3F12.6)') '# Time: ',time_cur, '  Projectile position (A): ',xatom(:,ncenter_nuclei)*bohr_A
 enddo

 do ir=1,nr_line_rho
   rr(:) = (ir - 1.d0) / (nr_line_rho - 1) * ( point_b(:) - point_a(:) ) + point_a(:)

   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi_cmplx(:,ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,:,ispin) )
     write(line_rho(ispin),'(50(e16.8,2x))') DOT_PRODUCT(rr(:),u(:)), &
                           SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(:nocc_dim,ispin) ) - rho_start(ir,ispin)
   enddo
 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
 end do

 deallocate(phi_cmplx)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_diff_cmplx


!=========================================================================
subroutine calc_rho_initial_cmplx(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num,time_cur, &
                                  nr_line_rho,point_a,point_b,rho_start)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer,intent(in)         :: num
 real(dp),intent(in)        :: time_cur
 real(dp),intent(in)        :: point_a(3),point_b(3)
 integer,intent(in)         :: nr_line_rho
 real(dp),intent(out)       :: rho_start(nr_line_rho,nspin)
!=====
 integer                    :: gt,ispin,ir
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: u(3)
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: line_rho(nspin)
 character(len=200)         :: file_name
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 write(stdout,'(/,1x,a)') 'Calculating initial electronic denstiy along one line'

 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi_cmplx(nocc_dim,nspin))

 do ispin=1,nspin
   write(file_name,'(a)') 'total_initial_line_density.dat'
   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,F12.6,a,3F12.6)') '# Time: ',time_cur, '  Projectile position (A): ',xatom(:,ncenter_nuclei)*bohr_A
 enddo

 do ir=1,nr_line_rho
   rr(:) = (ir - 1.d0) / (nr_line_rho - 1) * ( point_b(:) - point_a(:) ) + point_a(:)

   call calculate_basis_functions_r(basis,rr,basis_function_r)

   do ispin=1,nspin
     phi_cmplx(:,ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,:,ispin) )
     rho_start(ir,ispin) = SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(:nocc_dim,ispin) )
     write(line_rho(ispin),'(50(e16.8,2x))') DOT_PRODUCT(rr(:),u(:)),rho_start(ir,ispin)
   enddo
 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
 end do

 deallocate(phi_cmplx)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine calc_rho_initial_cmplx


!=========================================================================
subroutine initialize_rho_diff_cmplx(nr_line_rho,point_a,point_b)
 implicit none

 real(dp),intent(out)       :: point_a(3),point_b(3)
 integer,intent(out)        :: nr_line_rho
!=====
 logical                    :: file_exists
 integer                    :: linefile
!=====

 if( .NOT. is_iomaster ) return

 inquire(file='manual_plot_rho_tddft',exist=file_exists)
 if(file_exists) then
   open(newunit=linefile,file='manual_plot_rho_tddft',status='old')
   read(linefile,*) nr_line_rho
   read(linefile,*) point_a(:)
   read(linefile,*) point_b(:)
   close(linefile)
 else
   nr_line_rho=5000
   point_a = (/ 0.0_dp, 0.0_dp, 0.0_dp  /)
   point_b = (/ 0.0_dp, 0.0_dp, 10.0_dp  /)
   call issue_warning('initialize_rho_diff_cmplx: manual_plot_rho_tddft file was not found')
 endif

end subroutine initialize_rho_diff_cmplx


!=========================================================================
subroutine plot_rho_traj_bunch_cmplx(nstate,nocc_dim,basis,occupation,c_matrix_cmplx,num,time_cur)
 implicit none

 integer,intent(in)         :: nstate
 integer,intent(in)         :: nocc_dim
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: occupation(nstate,nspin)
 complex(dp),intent(in)     :: c_matrix_cmplx(basis%nbf,nocc_dim,nspin)
 integer                    :: num
 real(dp),intent(in)        :: time_cur
!=====
 integer                    :: nr=1000,nh=100
 integer                    :: gt
 integer                    :: nocc(2),nocc_max
 real(dp),parameter         :: length=6.0_dp
 integer                    :: ibf
 integer                    :: istate,ispin
 real(dp)                   :: rr(3)
 complex(dp),allocatable    :: phi_cmplx(:,:)
 real(dp)                   :: point_a(3),point_b(3),point_c(3),u(3)
 real(dp)                   :: a_cur(3), b_cur(3)
 logical                    :: file_exists
 real(dp)                   :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                   :: xxmin,xxmax
 real(dp)                   :: dx,dy,dz
 real(dp)                   :: basis_function_r(basis%nbf)
 integer                    :: ir,ih
 integer                    :: ibf_cart,ni_cart,ni,li,i_cart
 real(dp),allocatable       :: basis_function_r_cart(:)
 integer,allocatable        :: ocubefile(:,:)
 integer                    :: line_rho(nspin)
 character(len=200)         :: file_name
 integer                    :: linefile
 integer                    :: i_max_atom
 real(dp)                   :: vec_length
 real(dp)                   :: integral, deltar
!=====

 if( .NOT. is_iomaster ) return

 call start_clock(timing_print_line_rho_tddft)

 gt = get_gaussian_type_tag(basis%gaussian_type)

 if( .NOT. in_rt_tddft ) then
   write(stdout,'(/,1x,a)') 'Plotting electronic density along the projectile trajectory for several impact parameters'
 endif
 ! Find highest occupied state
 nocc = 0
 nocc_max = 0
 do ispin=1,nspin
   do istate=1,nstate
     if( occupation(istate,ispin) < completely_empty)  cycle
     nocc(ispin) = istate
     if( istate > nocc_max ) nocc_max = istate
   enddo
   if( .NOT. (ALL( occupation(nocc(ispin)+1,:) < completely_empty )) ) then
     call die('Not all occupied states selected in the plot_cube_wfn_cmplx')
   endif
 enddo

 inquire(file='manual_dens_traj_tddft',exist=file_exists)
 if(file_exists) then
   open(newunit=linefile,file='manual_dens_traj_tddft',status='old')
   read(linefile,*) point_a(:)
   read(linefile,*) point_b(:)
   read(linefile,*) point_c(:)
   read(linefile,*) nr
   read(linefile,*) nh

   close(linefile)
 else
   point_a = (/ 0.0_dp,  0.0_dp, -10.0_dp  /)
   point_b = (/ 0.0_dp,  0.0_dp,  10.0_dp  /)
   point_c = (/ 3.49_dp, 0.0_dp, -10.0_dp  /)
   call issue_warning('plot_line_wfn_cmplx: manual_dens_traj_tddft file was not found')
 endif
! point_b(:) = point_b(:) / bohr_A
! point_a(:) = point_a(:) / bohr_A
! In analogy with cube file, this file is also in Bohr
 u(:) = point_b(:) - point_a(:)
 u(:) = u(:) / NORM2(u)
 allocate(phi_cmplx(nstate,nspin))

 do ispin=1,nspin
   write(file_name,'(i3.3,a,i1,a)') num,'_',ispin,'_integral_density.dat'
   open(newunit=line_rho(ispin),file=file_name)
   write(line_rho(ispin),'(a,i3)') '# density integral file generated from MOLGW for spin ',ispin
   write(line_rho(ispin),'(a,f9.5)') '# time_cur = ', time_cur
 enddo

 deltar=NORM2( point_b(:) - point_a(:) )/nr
 do ih=0,nh
   do ispin=1,nspin

     a_cur(:)=point_a(:)+(point_c(:)-point_a(:))*ih/nh
     b_cur(:)=point_b(:)+(point_c(:)-point_a(:))*ih/nh

     integral=0.d0
!     write(stdout,*) ih
     do ir=0,nr
       rr(:) = a_cur(:) + ( b_cur(:) - a_cur(:) ) * ir / nr
       call calculate_basis_functions_r(basis,rr,basis_function_r)
       phi_cmplx(:,ispin) = MATMUL( basis_function_r(:) , c_matrix_cmplx(:,:,ispin) )
       integral=integral+SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(:,ispin) )*deltar
     enddo

     write(line_rho(ispin),'(50(e16.8,2x))') NORM2(a_cur(:)-point_a(:)),integral, &
                                             SUM( ABS(phi_cmplx(:,ispin))**2 * occupation(:,ispin) )
   enddo
 enddo

 do ispin=1,nspin
   close(line_rho(ispin))
 end do

 deallocate(phi_cmplx)

 call stop_clock(timing_print_line_rho_tddft)

end subroutine plot_rho_traj_bunch_cmplx


!=========================================================================
subroutine write_cube_from_header(rootname,basis,occupation,c_matrix)
 implicit none
 character(len=*),intent(in) :: rootname
 type(basis_set),intent(in)  :: basis
 real(dp),intent(in)         :: occupation(:,:)
 real(dp),intent(in)         :: c_matrix(:,:,:)
!=====
 integer                     :: nstate
 integer                     :: icubefile
 character(len=200)          :: file_name,tmp
 real(dp),allocatable        :: phi(:,:),pot(:,:,:)
 real(dp),allocatable        :: pot_i(:,:)
 real(dp)                    :: rr(3)
 real(dp)                    :: xmin,xmax,ymin,ymax,zmin,zmax
 real(dp)                    :: dr(3,3)
 real(dp)                    :: basis_function_r(basis%nbf)
 real(dp)                    :: chi2
 integer                     :: natom1
 integer                     :: n1,n2,n3
 integer                     :: i1,i2,i3
 integer                     :: istate,ispin,icenter
 integer,allocatable         :: ocubefile(:,:)
 integer                     :: ocuberho(nspin)
 real(dp)                    :: dv,nelect,rhor
 integer                     :: stride=6
 logical                     :: file_exists
 logical,parameter           :: read_volumetric_data= .FALSE.
 logical,parameter           :: write_wfn= .FALSE.
!=====

 if( .NOT. is_iomaster ) return

 write(stdout,'(/,1x,a)') 'Plotting some selected wavefunctions in a cube file based on a previous cube file grid'

 nstate = SIZE(occupation(:,:),DIM=1)

 file_name = 'in.cube'
 inquire(file=file_name,exist=file_exists)
 if( .NOT. file_exists ) then
   call issue_warning('write_cube_from_header: in.cube file not found. Skip cube file generation')
   return
 endif
 open(newunit=icubefile,file=TRIM(file_name),action='read',status='old')
 read(icubefile,*) tmp
 read(icubefile,*) tmp
 read(icubefile,*) natom1,xmin,ymin,zmin
 read(icubefile,*) n1,dr(:,1)
 read(icubefile,*) n2,dr(:,2)
 read(icubefile,*) n3,dr(:,3)
 do icenter=1,natom1
   read(icubefile,*)
 enddo
 if( natom1 /= ncenter_nuclei ) then
   call issue_warning('write_cube_from_header: wrong input number of atoms. Skip cube file generation')
   return
 endif
 dv = determinant_3x3_matrix(dr)
 if( read_volumetric_data ) then
   allocate(pot(n1,n2,n3))
   do i1=1,n1
     do i2=1,n2
       do i3=1,(n3/stride-1)*stride+1,stride
         read(icubefile,*) pot(i1,i2,i3:i3+stride-1)
       enddo
       if( modulo(n3,stride) /=0 ) read(icubefile,*) pot(i1,i2,(n3/stride)*stride+1:n3)
     enddo
   enddo
   write(stdout,*) 'normalization:',SUM(pot(:,:,:))*dv
 endif
 close(icubefile)


 allocate(phi(cube_state_min:cube_state_max,nspin))
 allocate(ocubefile(cube_state_min:cube_state_max,nspin))
 if( read_volumetric_data ) allocate(pot_i(cube_state_min:cube_state_max,nspin))

 write(stdout,'(1x,a25,i3,1x,i3,1x,i3)')     'Selected grid: ',n1,n2,n3
 write(stdout,'(1x,a25,i5,1x,i5)')    'Selected state range: ',cube_state_min,cube_state_max

 !
 ! check whether cube_state_min:cube_state_max spans all the occupied states
 if( .TRUE. ) then
   do ispin=1,nspin
     write(file_name,'(a,i1,a)') 'rho_'//TRIM(rootname)//'_',ispin,'.cube'
     open(newunit=ocuberho(ispin),file=file_name)
     write(ocuberho(ispin),'(a)') 'cube file generated from MOLGW'
     write(ocuberho(ispin),'(a,i4)') 'density for spin ',ispin
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin,zmin
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') n1,dr(:,1)
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') n2,dr(:,2)
     write(ocuberho(ispin),'(i6,3(f12.6,2x))') n3,dr(:,3)
     do icenter=1,ncenter_nuclei
       write(ocuberho(ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
     enddo
   enddo
 endif

 if( write_wfn ) then
   do istate=cube_state_min,cube_state_max
     do ispin=1,nspin
       write(file_name,'(a,i3.3,a,i1,a)') 'wfn_'//TRIM(rootname)//'_',istate,'_',ispin,'.cube'
       open(newunit=ocubefile(istate,ispin),file=file_name)
       write(ocubefile(istate,ispin),'(a)') 'cube file generated from MOLGW'
       write(ocubefile(istate,ispin),'(a,i4)') 'wavefunction ',cube_state_min
       write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') ncenter_nuclei,xmin,ymin,zmin
       write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') n1,dr(:,1)
       write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') n2,dr(:,2)
       write(ocubefile(istate,ispin),'(i6,3(f12.6,2x))') n3,dr(:,3)
       do icenter=1,ncenter_nuclei
         write(ocubefile(istate,ispin),'(i6,4(2x,f12.6))') NINT(zatom(icenter)),0.0,xatom(:,icenter)
       enddo
     enddo
   enddo
 endif

 if( read_volumetric_data ) pot_i(:,:) = 0.0_dp
 chi2 = 0.0_dp
 nelect = 0.0_dp
 do i1=1,n1
   do i2=1,n2
     do i3=1,n3
       rr(1) = xmin
       rr(2) = ymin
       rr(3) = zmin
       rr(:) = rr(:) + (i1-1) * dr(:,1) + (i2-1) * dr(:,2) + (i3-1) * dr(:,3)

       call calculate_basis_functions_r(basis,rr,basis_function_r)

       do ispin=1,nspin
         phi(cube_state_min:cube_state_max,ispin) = MATMUL( basis_function_r(:) , c_matrix(:,cube_state_min:cube_state_max,ispin) )
       enddo

       do istate=cube_state_min,cube_state_max
         do ispin=1,nspin
           if( write_wfn ) &
             write(ocubefile(istate,ispin),'(50(e16.8,2x))') phi(istate,ispin)
           if( read_volumetric_data ) &
             pot_i(istate,ispin) = pot_i(istate,ispin) - pot(i1,i2,i3) * phi(istate,ispin)**2 * dv
         enddo
       enddo

       !
       ! check whether cube_state_min:cube_state_max spans all the occupied states
       !if( ALL( occupation(cube_state_max+1,:) < completely_empty ) ) then
       if( .TRUE. ) then
         do ispin=1,nspin
           rhor =  SUM( phi(:,ispin)**2 * occupation(cube_state_min:cube_state_max,ispin) )
           nelect = nelect + rhor * dv
           write(ocuberho(ispin),'(1x,es12.4)') rhor
           if( read_volumetric_data ) then
             chi2 = chi2 + ( pot(i1,i2,i3) - SUM( phi(:,ispin)**2 * occupation(cube_state_min:cube_state_max,ispin) ) )**2
           endif
         enddo
       endif


     enddo
   enddo
 enddo
 do ispin=1,nspin
   do istate=cube_state_min,cube_state_max
     if( write_wfn ) close(ocubefile(istate,ispin))
   enddo
   close(ocuberho(ispin))
 enddo

 write(stdout,'(1x,a25,f14.9)') 'Number of electrons: ',nelect

 deallocate(phi)
 if( ALLOCATED(pot) ) deallocate(pot)
 if( ALLOCATED(pot_i) ) deallocate(pot_i)
 deallocate(ocubefile)

end subroutine write_cube_from_header


!=========================================================================
subroutine read_gaussian_fchk(read_fchk_in,file_name,basis,p_matrix_out)
 implicit none

 character(len=*),intent(in) :: read_fchk_in
 character(len=*),intent(in) :: file_name
 type(basis_set),intent(in)  :: basis
 real(dp),intent(out)        :: p_matrix_out(basis%nbf,basis%nbf,nspin)
!=====
 integer,parameter :: stride=5
 logical :: file_exists,found
 integer :: fu
 integer :: istat
 integer :: ispin,ibf,jbf,ijbf,ibf_molgw
 integer :: nel
 real(dp) :: swap(basis%nbf,basis%nbf)
 real(dp),allocatable :: p_matrix_read(:)
 character(len=256) :: line
 character(len=100) :: keyword
 integer :: am,nbf_am
 type g2m
   real(dp),allocatable    :: block(:,:)
 end type
 type(g2m),allocatable :: reordering(:)
!=====

 p_matrix_out(:,:,:) = 0.0_dp


 if( nspin /= 1 ) then
   call issue_warning('read_gaussian_fchk: unrestricted calculations not coded yet')
   return
 endif

 allocate(reordering(0:MOLGW_LMAX))
 do am=0,MOLGW_LMAX
   nbf_am = number_basis_function_am(basis%gaussian_type,am)
   allocate(reordering(am)%block(nbf_am,nbf_am))
   reordering(am)%block(:,:) = 0
 enddo

 if( is_iomaster ) then

   select case(TRIM(read_fchk_in))
   case('CC')
     keyword = 'Total CC Density'
   case('MP2')
     keyword = 'Total MP2 Density'
   case('SCF')
     keyword = 'Total SCF Density'
   case default
     write(stdout,*) read_fchk_in
     call die('read_gaussian_fchk: invalid choice for input variable read_fchk')
   end select

   write(stdout,'(/,1x,a,a)') 'Reading an existing Gaussian formatted checkpoint point: ',&
                              TRIM(file_name)
   write(stdout,'(1x,a,a)')   'Reading field: ',TRIM(keyword)

   inquire(file=file_name,exist=file_exists)
   if( .NOT. file_exists) then
     call issue_warning('File not found: ' // TRIM(file_name))
     return
   endif

   write(stdout,'(1x,a,a)') 'Density matrix read: ',TRIM(read_fchk_in)

   nel = (basis%nbf*(basis%nbf+1))/2
   allocate(p_matrix_read(nel))


   open(newunit=fu,file=TRIM(file_name),status='old',action='read')

   ! Read the fchk file until the keyword is found
   found = .FALSE.
   do while( .NOT. found )
     read(fu,'(a)',iostat=istat) line
     if( IS_IOSTAT_END(istat) ) then
       call issue_warning(TRIM(keyword)//' not found in file')
       return
     endif
     found = ( INDEX(line,TRIM(keyword)) /= 0 )
   enddo

   do ispin=1,nspin
     do ijbf=1,(nel/stride-1)*stride+1,stride
       read(fu,*) p_matrix_read(ijbf:ijbf+stride-1)
     enddo
     if( MODULO(nel,stride) /=0 ) read(fu,*) p_matrix_read((nel/stride)*stride+1:nel)
     ijbf = 0
     do ibf=1,basis%nbf
       do jbf=1,ibf
         ijbf = ijbf + 1
         p_matrix_out(ibf,jbf,ispin) = p_matrix_read(ijbf)
         p_matrix_out(jbf,ibf,ispin) = p_matrix_read(ijbf)
       enddo
     enddo
   enddo
   close(fu)

   !
   ! Reorder the basis functions from Gaussian to Libint convention
   !
   if( basis%gaussian_type == 'CART') then
     ! s and p orbitals are unchanged
     ! gaussian d orbital order is xx, yy, zz, xy, yz, xz
     ! libint   d orbital order is xx, xy, xz, yy, yz, zz
     reordering(0)%block(:,:) = 1

     reordering(1)%block(:,:) = RESHAPE( [ 1, 0, 0, 0, 1, 0, 0, 0, 1] , [ 3, 3 ] )

     reordering(2)%block(:,:) = RESHAPE( [ 1, 0, 0, 0, 0, 0, &
                                           0, 0, 0, 1, 0, 0, &
                                           0, 0, 0, 0, 1, 0, &
                                           0, 1, 0, 0, 0, 0, &
                                           0, 0, 0, 0, 0, 1, &
                                           0, 0, 1, 0, 0, 0 ] , [ 6, 6 ] )

     reordering(3)%block(:,:) = RESHAPE( [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, &    !OK
                                           0, 0, 0, 0, 1, 0, 0, 0, 0, 0, &
                                           0, 0, 0, 0, 0, 1, 0, 0, 0, 0, &
                                           0, 0, 0, 1, 0, 0, 0, 0, 0, 0, &
                                           0, 0, 0, 0, 0, 0, 0, 0, 0, 1, &
                                           0, 0, 0, 0, 0, 0, 1, 0, 0, 0, &
                                           0, 1, 0, 0, 0, 0, 0, 0, 0, 0, &    !OK
                                           0, 0, 0, 0, 0, 0, 0, 0, 1, 0, &
                                           0, 0, 0, 0, 0, 0, 0, 1, 0, 0, &
                                           0, 0, 1, 0, 0, 0, 0, 0, 0, 0 ] , [ 10, 10 ] )    !OK

     do am=4,MOLGW_LMAX
       nbf_am = number_basis_function_am(basis%gaussian_type,am)
       do ibf=1,nbf_am
         reordering(am)%block(ibf,nbf_am+1-ibf) = 1
       enddo
     enddo
   else
     ! s
     reordering(0)%block(1,1) = 1
     ! p
     reordering(1)%block(1,3) = 1
     reordering(1)%block(2,1) = 1
     reordering(1)%block(3,2) = 1
     do am=2,MOLGW_LMAX
       nbf_am = number_basis_function_am(basis%gaussian_type,am)
       do ibf=1,nbf_am
         ibf_molgw = ( nbf_am + 1 ) / 2 - ( 2 * MODULO(ibf,2) - 1 ) * ibf / 2
         reordering(am)%block(ibf,ibf_molgw) = 1
       enddo
     enddo
   endif

   swap(:,:) = 0.0_dp
   ibf = 1
   do while( ibf <= basis%nbf )
     am = basis%bff(ibf)%am
     if( am > MOLGW_LMAX ) &
       call die('read_gaussian_fchk: too high angular momentum, not coded yet')
     nbf_am = number_basis_function_am(basis%gaussian_type,am)

     swap(ibf:ibf+nbf_am-1,ibf:ibf+nbf_am-1) = reordering(am)%block(:,:)

     ibf = ibf + nbf_am

   enddo

   p_matrix_out(:,:,1) = MATMUL( TRANSPOSE(swap), MATMUL(p_matrix_out(:,:,1),swap) )

   do am=0,MOLGW_LMAX
     deallocate(reordering(am)%block)
   enddo
   deallocate(reordering)

   !call dump_out_matrix(.TRUE.,'gaussian density matrix',SIZE(p_matrix_out,DIM=1),SIZE(p_matrix_out,DIM=3),p_matrix_out)


   deallocate(p_matrix_read)

 endif

 ! Broadcast the density matrix from proc iomaster to all the other procs.
 call world%bcast(iomaster,p_matrix_out)


end subroutine read_gaussian_fchk


!=========================================================================
subroutine write_energy_qp(energy_qp)
 implicit none

 real(dp),intent(in) :: energy_qp(:,:)
!=====
 integer           :: nstate
 integer           :: energy_qpfile
 integer           :: istate
!=====

 !
 ! Only the proc iomaster writes down the ENERGY_QP file
 if( .NOT. is_iomaster) return

 nstate = SIZE(energy_qp,DIM=1)

 write(stdout,'(/,a)') ' Writing ENERGY_QP file'


 open(newunit=energy_qpfile,file='ENERGY_QP',form='formatted')

 write(energy_qpfile,*) nspin
 write(energy_qpfile,*) nstate
 select case(nspin)
 case(1)
   do istate=1,nstate
     write(energy_qpfile,*) istate,energy_qp(istate,1)
   enddo
 case(2)
   do istate=1,nstate
     write(energy_qpfile,*) istate,energy_qp(istate,1),energy_qp(istate,2)
   enddo
 end select

 close(energy_qpfile)


end subroutine write_energy_qp


!=========================================================================
subroutine read_energy_qp(nstate,energy_qp,reading_status)
 implicit none

 integer,intent(in)   :: nstate
 integer,intent(out)  :: reading_status
 real(dp),intent(out) :: energy_qp(nstate,nspin)
!=====
 integer           :: energy_qpfile
 integer           :: istate,jstate
 integer           :: nspin_read,nstate_read
 logical           :: file_exists_capitalized,file_exists
!=====

 write(stdout,'(/,a)') ' Reading ENERGY_QP file'

 inquire(file='ENERGY_QP',exist=file_exists_capitalized)
 inquire(file='energy_qp',exist=file_exists)

 if(file_exists_capitalized) then
   open(newunit=energy_qpfile,file='ENERGY_QP',form='formatted',status='old')
 else if(file_exists) then
   open(newunit=energy_qpfile,file='energy_qp',form='formatted',status='old')
 endif

 if( file_exists_capitalized .OR. file_exists ) then
   read(energy_qpfile,*) nspin_read
   read(energy_qpfile,*) nstate_read
   if( nstate_read /= nstate .OR. nspin_read /= nspin ) then
     call issue_warning('ENERGY_QP file does not have the correct dimensions')
     reading_status=2
   else
     do istate=1,nstate
       read(energy_qpfile,*) jstate,energy_qp(istate,:)
       ! Scissor operator
       if( jstate == -1 ) then
         reading_status=-1
         close(energy_qpfile)
         return
       endif
     enddo
     reading_status=0
   endif
   close(energy_qpfile)
 else
   reading_status=1
   call issue_warning('files ENERGY_QP and energy_qp do not exist')
 endif


end subroutine read_energy_qp


!=========================================================================
subroutine evaluate_wfn_r(nspin,nstate,basis,c_matrix,istate1,istate2,ispin,rr,wfn_i)
 implicit none
 integer,intent(in)         :: nspin
 type(basis_set),intent(in) :: basis
 integer,intent(in)         :: nstate
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer,intent(in)         :: istate1,istate2,ispin
 real(dp),intent(in)        :: rr(3)
 real(dp),intent(out)       :: wfn_i(istate1:istate2)
!=====
 real(dp)                   :: basis_function_r(basis%nbf)
!=====

 ! First precalculate all the needed basis function evaluations at point rr
 call calculate_basis_functions_r(basis,rr,basis_function_r)

 ! Then rotate
 wfn_i(istate1:istate2) = MATMUL( basis_function_r(:) , c_matrix(:,istate1:istate2,ispin) )


end subroutine evaluate_wfn_r


!=========================================================================
function wfn_parity(nstate,basis,c_matrix,istate,ispin)
 implicit none
 integer,intent(in)         :: nstate
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer,intent(in)         :: istate,ispin
 integer                    :: wfn_parity
!=====
 real(dp) :: phi_tmp1(1),phi_tmp2(1),xtmp(3)
!=====

 xtmp(1) = xcenter(1) +  2.0_dp
 xtmp(2) = xcenter(2) +  1.0_dp
 xtmp(3) = xcenter(3) +  3.0_dp
 call evaluate_wfn_r(nspin,nstate,basis,c_matrix,istate,istate,ispin,xtmp,phi_tmp1)
 xtmp(1) = xcenter(1) -  2.0_dp
 xtmp(2) = xcenter(2) -  1.0_dp
 xtmp(3) = xcenter(3) -  3.0_dp
 call evaluate_wfn_r(nspin,nstate,basis,c_matrix,istate,istate,ispin,xtmp,phi_tmp2)

 if( ABS(phi_tmp1(1) - phi_tmp2(1))/ABS(phi_tmp1(1)) < 1.0e-6_dp ) then
   wfn_parity = 1
 else
   wfn_parity = -1
 endif


end function wfn_parity


!=========================================================================
function wfn_reflection(nstate,basis,c_matrix,istate,ispin)
 implicit none
 integer,intent(in)         :: nstate
 type(basis_set),intent(in) :: basis
 real(dp),intent(in)        :: c_matrix(basis%nbf,nstate,nspin)
 integer,intent(in)         :: istate,ispin
 integer                    :: wfn_reflection
!=====
 real(dp) :: phi_tmp1(1),phi_tmp2(1)
 real(dp) :: xtmp1(3),xtmp2(3)
 real(dp) :: proj
!=====

 xtmp1(1) = xatom(1,1) +  2.0_dp
 xtmp1(2) = xatom(2,1) +  1.0_dp
 xtmp1(3) = xatom(3,1) +  3.0_dp
 call evaluate_wfn_r(nspin,nstate,basis,c_matrix,istate,istate,ispin,xtmp1,phi_tmp1)

 proj = DOT_PRODUCT( xtmp1 , xnormal )
 xtmp2(:) = xtmp1(:) -  2.0_dp * proj * xnormal(:)
 call evaluate_wfn_r(nspin,nstate,basis,c_matrix,istate,istate,ispin,xtmp2,phi_tmp2)

 if( ABS(phi_tmp1(1) - phi_tmp2(1))/ABS(phi_tmp1(1)) < 1.0e-6_dp ) then
   wfn_reflection = 1
 else if( ABS(phi_tmp1(1) + phi_tmp2(1))/ABS(phi_tmp1(1)) < 1.0e-6_dp ) then
   wfn_reflection = -1
 else
   wfn_reflection = 0
 endif


end function wfn_reflection


!=========================================================================
subroutine calculation_parameters_yaml(nbf,auxil_nbf,nstate)
 implicit none
 integer,intent(in)  :: nbf,auxil_nbf,nstate
!=====

 if( .NOT. ( print_yaml_ .AND. is_iomaster ) ) return

 write(unit_yaml,'(/,a)')  'calculation parameters:'
 write(unit_yaml,'(4x,a,1x,i6)')  'basis functions:             ',nbf
 write(unit_yaml,'(4x,a,1x,i6)')  'independent basis functions: ',nstate
 write(unit_yaml,'(4x,a,1x,i6)')  'auxiliary basis functions:   ',auxil_nbf

end subroutine calculation_parameters_yaml


!=========================================================================
subroutine evaluate_memory(nbf,auxil_nbf,nstate,occupation)
 implicit none
 integer,intent(in)  :: nbf,auxil_nbf,nstate
 real(dp),intent(in) :: occupation(:,:)
!=====
 integer :: ncore_W,nvirtual_W,nhomo
 real(dp) :: mem
!=====

 write(stdout,'(/,1x,70("="))')

 write(stdout,'(/,1x,a)') 'Memory consumption predictor'
 write(stdout,'(1x,a,/)') 'The above numbers are just for information purpose. Handle with care.'

 write(stdout,'(/,1x,a)') '==== Electron Repulsion Integrals (MPI distributed)'
 write(stdout,'(5x,a30,1x,i10)') 'npair =',npair
 if( has_auxil_basis ) then
   write(stdout,'(5x,a30,1x,i10)') 'auxil_basis%nbf =',auxil_nbf
   write(stdout,'(5x,a30,1x,i10)') 'eri3_nbatch =',eri3_nbatch
   !                                        eri_3center +       eri_3center_tmp
   mem = REAL(npair,dp) * REAL(auxil_nbf,dp) * ( 1.0_dp + 1.0_dp / REAL(eri3_nbatch,dp) )
 else
   !          eri_4center    / symmetry
   mem = REAL(npair,dp)**2   / 2.0_dp
 endif
 mem = mem * 8.0_dp / 1024_dp**3
 write(stdout,'(5x,a30,1x,f14.3,1x,a)') 'Memory =',mem,'(Gb)'


 write(stdout,'(/,1x,a)')  '==== Pulay DIIS (never distributed)'
 write(stdout,'(5x,a30,1x,i10)') 'basis%nbf =',nbf
 write(stdout,'(5x,a30,1x,i10)') 'nstate =',nstate
 write(stdout,'(5x,a30,1x,i10)') 'nspin =',nspin
 write(stdout,'(5x,a30,1x,i10)') 'npulay_hist =',npulay_hist
 !                                        ham_hist & p_matrix_hist      res_hist
 mem = REAL(npulay_hist * nspin,dp) * (  2.0_dp * REAL(nbf,dp)**2    +  REAL(nstate,dp)**2 )
 mem = mem * 8.0_dp / 1024_dp**3
 write(stdout,'(5x,a30,1x,f14.3,1x,a)') 'Memory =',mem,'(Gb)'


 write(stdout,'(/,1x,a)')  '==== RPA response calculation (MPI distributed)'
 ncore_W      = ncorew
 nvirtual_W   = MIN(nvirtualw,nstate+1)
 if(is_frozencore) then
   if( ncore_W == 0) ncore_W = atoms_core_states()
 endif
 nhomo = get_number_occupied_states(occupation)

 write(stdout,'(5x,a)')  '== RPA response'
 write(stdout,'(5x,a30,1x,i10)') 'Active occupied states =',nhomo-ncore_W
 write(stdout,'(5x,a30,1x,i10)') 'Active virtual states =',nvirtual_W-nhomo-1
 write(stdout,'(5x,a30,1x,i10)') 'nspin =',nspin
 !                                                                            A+B , Z
 mem = ( REAL(nhomo-ncore_W,dp) * REAL(nvirtual_W-nhomo-1,dp) * nspin )**2 * 2.0_dp
 mem = mem * 8.0_dp / 1024_dp**3
 write(stdout,'(5x,a30,1x,f14.3,1x,a)') 'Memory =',mem,'(Gb)'

 write(stdout,'(5x,a)')  '== MO Electron Repulsion Integrals'
 write(stdout,'(5x,a30,1x,i10)') 'Active occupied states =',nhomo-ncore_W
 write(stdout,'(5x,a30,1x,i10)') 'Active virtual states =',nvirtual_W-nhomo-1
 if( has_auxil_basis ) then
   write(stdout,'(5x,a30,1x,i10)') 'auxil_basis%nbf =',auxil_nbf
   !                                                              eri_3center_ao
   mem = REAL(nhomo-ncore_W,dp) * REAL(nvirtual_W-nhomo-1,dp) * nspin * auxil_nbf
 else
   !          eri_eigenstate_klmin(
   mem = REAL(nbf,dp)**3 * nspin
 endif
 mem = mem * 8.0_dp / 1024_dp**3
 write(stdout,'(5x,a30,1x,f14.3,1x,a)') 'Memory =',mem,'(Gb)'


 write(stdout,'(/,1x,a)')  '==== RT-TDDFT (never distributed)'
 write(stdout,'(5x,a30,1x,i10)') 'nstate =',nstate
 write(stdout,'(5x,a30,1x,i10)') 'nspin =',nspin
 write(stdout,'(5x,a30,1x,i10)') 'n_hist =',n_hist
 !               h_small_hist_cmplx(:,:,:,:)  h_small_cmplx          h_cmplx
 mem = REAL(nstate,dp)**2 * nspin * ( n_hist  +    1            ) + REAL(nbf,dp)**2 * nspin
 mem = mem * 16.0_dp / 1024_dp**3
 write(stdout,'(5x,a30,1x,f14.3,1x,a)') 'Memory =',mem,'(Gb)'



 write(stdout,'(/,1x,70("="))')


 call stop_clock(timing_prescf)
 call stop_clock(timing_total)
 call this_is_the_end()

end subroutine evaluate_memory


!=========================================================================
subroutine dump_c_matrix_cmplx_hdf5(fid, gid, c_matrix_cmplx, isnap, initialize, finalize)
 use m_hdf5_tools
 use m_inputparam
 implicit none
 integer(HID_T), intent(inout) :: fid, gid
 integer,intent(in)          :: isnap
 complex(dp),intent(in)      :: c_matrix_cmplx(:,:,:)
 logical,intent(in),optional :: initialize
 logical,intent(in),optional :: finalize
 !=====
 character(len=200)          :: file_name, group_name, snap_name
 logical                     :: init_, final_
 !=====

#if defined(HAVE_HDF5)

 if( .NOT. is_iomaster ) return

 init_ = .FALSE.
 final_ = .FALSE.

 if( PRESENT(initialize) ) init_ = initialize
 if( PRESENT(finalize) ) final_ = finalize

 if( init_ ) then

   fid = 0
   gid = 0

   write(file_name,'(a)') 'rt_tddft.h5'
   call hdf_open_file(fid, trim(file_name), status='NEW')

   call hdf_write_dataset(fid, 'time_step', time_step)

   write(group_name,'(a)') 'c_matrix_cmplx'
   call hdf_create_group(fid, trim(group_name))
   call hdf_open_group(fid, trim(group_name), gid)


 else if( final_ ) then

   call hdf_close_group(gid) 
   call hdf_close_file(fid)
   return

 end if

 write(snap_name,'(a,I0,a)') 'snap_', isnap, '_real'
 call hdf_write_dataset(gid, TRIM(snap_name), REAL(c_matrix_cmplx, dp))

 write(snap_name,'(a,I0,a)') 'snap_', isnap, '_imag'
 call hdf_write_dataset(gid, TRIM(snap_name), AIMAG(c_matrix_cmplx))

#else

call die('To print c_matrix_cmplx into an HDF5 file, &
MOLGW must be compiled with HDF5: HDF5_ROOT must be specified &
and the -DHAVE_HDF5 compilation option must be activated')

#endif

 end subroutine dump_c_matrix_cmplx_hdf5

!=========================================================================
end module m_io
!=========================================================================
